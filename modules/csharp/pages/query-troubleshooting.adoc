:docname: query-troubleshooting
:page-module: csharp
:page-relative-src-path: query-troubleshooting.adoc
:page-origin-url: https://github.com/couchbase/docs-couchbase-lite.git
:page-origin-start-path:
:page-origin-refname: antora-assembler-simplification
:page-origin-reftype: branch
:page-origin-refhash: (worktree)
[#csharp:query-troubleshooting:::]
== Query Troubleshooting
// BEGIN -- page -- <module>-query-trouble-shooting.adoc
// Uses:
// -- attribute -- partial$ -- modules/<module>/pages/_partials
// -- attribute -- root-partials -- modules/ROOT/pages/_partials
// -- attribute -- root-commons -- modules/ROOT/pages/_partials/commons/common-
// -- attribute -- various 'xref' page links from {root-partials}_define_page_index.adoc
// -- standard header file -- partial$_set_page_context_for_<module>.adoc[]
// -- common module -- {root-commons}query-troubleshooting.adoc
//
:page-aliases: learn/csharp-query-troubleshooting.adoc
:page-role:
:description: Couchbase Lite Queries -- troubleshooting


:version: {major}.{minor}
:vs-version: {vs-major}.{vs-minor}
:version-full: {major}.{minor}.{base}{empty}
:version-full-hyphenated: {major}-{minor}-{base}{empty}
:version-full-untagged: {major}.{minor}.{base}
:version-maintenance-android: {major}.{minor}.{maintenance-android}{empty}
:version-maintenance-c: {major}.{minor}.{maintenance-c}{empty}
:version-maintenance-net: {major}.{minor}.{maintenance-net}{empty}
:version-maintenance-java: {major}.{minor}.{maintenance-java}{empty}
:version-maintenance-ios: {major}.{minor}.{maintenance-ios}{empty}
:vs-version-maintenance-android: {vs-major}.{vs-minor}.{vs-maintenance-android}{empty}
:vs-version-maintenance-c: {vs-major}.{vs-minor}.{vs-maintenance-c}{empty}
:vs-version-maintenance-net: {vs-major}.{vs-minor}.{vs-maintenance-net}{empty}
:vs-version-maintenance-java: {vs-major}.{vs-minor}.{vs-maintenance-java}{empty}
:vs-version-maintenance-ios: {vs-major}.{vs-minor}.{vs-maintenance-ios}{empty}
:version-maintenance: {version}.{maintenance-net}{empty}
:version-maintenance-hyphenated: {major}-{minor}-{maintenance-net}{empty}
:vs-version-maintenance: {vs-version}.{vs-maintenance-net}{empty}
:vs-version-maintenance-hyphenated: {vs-major}-{vs-minor}-{vs-maintenance-net}{empty}


:version: {major}.{minor}
:vs-version: {vs-major}.{vs-minor}
:version-full: {major}.{minor}.{base}{empty}
:version-full-hyphenated: {major}-{minor}-{base}{empty}
:version-full-untagged: {major}.{minor}.{base}
:version-maintenance-android: {major}.{minor}.{maintenance-android}{empty}
:version-maintenance-c: {major}.{minor}.{maintenance-c}{empty}
:version-maintenance-net: {major}.{minor}.{maintenance-net}{empty}
:version-maintenance-java: {major}.{minor}.{maintenance-java}{empty}
:version-maintenance-ios: {major}.{minor}.{maintenance-ios}{empty}
:vs-version-maintenance-android: {vs-major}.{vs-minor}.{vs-maintenance-android}{empty}
:vs-version-maintenance-c: {vs-major}.{vs-minor}.{vs-maintenance-c}{empty}
:vs-version-maintenance-net: {vs-major}.{vs-minor}.{vs-maintenance-net}{empty}
:vs-version-maintenance-java: {vs-major}.{vs-minor}.{vs-maintenance-java}{empty}
:vs-version-maintenance-ios: {vs-major}.{vs-minor}.{vs-maintenance-ios}{empty}


// _show_page_header_block.adoc invoked in common module
[abstract]
--
Description -- _{description}_ +
_Abstract -- This content describes how to use the Couchbase Lite on C#.Net Query API's explain() method to examine a query_ +
Related Content -- xref:csharp:querybuilder.adoc#lbl-predquery[Predictive Queries] | xref:csharp:query-live.adoc[Live Queries] | xref:csharp:indexing.adoc[Indexing]
--


[discrete#csharp:query-troubleshooting:::query-explain]
=== Query Explain


[discrete#csharp:query-troubleshooting:::using]
==== Using
Query's https://docs.couchbase.com/mobile/{version-maintenance-net}/couchbase-lite-net/api/Couchbase.Lite.Query.#Couchbase_Lite__Query_IQuery_Explain[Explain()] method can provide useful insight when you are trying to diagnose query performance issues and-or optimize queries.
To examine how your query is working, either embed the call inside your app (see: <<csharp:query-troubleshooting:::use-qe-app>>), or use it interactively within a `cblite` shell (see: <<csharp:query-troubleshooting:::use-qe-cblite>>).

[#use-qe-app]
.Using Query Explain in App


[#csharp:query-troubleshooting:::use-qe-app]
====


// Show Main Snippet
// include::csharp:example$code_snippets/Program.cs[tags="query-explain-all", indent=0]
[source, C#]
----
using var query =
  QueryBuilder
    .Select(SelectResult.All())
    .From(DataSource.Collection(collection))
    .Where(Expression.Property("type").EqualTo(Expression.String("hotel")))
    .GroupBy(Expression.Property("country"))
    .OrderBy(Ordering.Property("title").Ascending()); // <.>

Console.WriteLine(query.Explain()); // <.>
----


====

<.> Construct your query as normal
<.> Call the query's `explain` method; All output is sent to the application's log file.

[#csharp:query-troubleshooting:::use-qe-cblite]
.Using Query Explain in cblite
====
[source, console]
----
cblite <your-database-name>.cblite2 // <.>

(cblite) select --explain domains group by country order by country, name // <.>

(cblite) query --explain {"GROUP_BY":[[".country"]],"ORDER_BY":[[".country"],[".name"]],"WHAT":[[".domains"]]} // <.>

----
<.> Within a terminal session open your database with `cblite` and enter your query
<.> Here the query is entered as a N1QL-query using `select` +
<.> Here the query is entered as a JSON-string using `query`
====


[discrete#csharp:query-troubleshooting:::output]
==== Output
The output from `https://docs.couchbase.com/mobile/{version-maintenance-net}/couchbase-lite-net/api/Couchbase.Lite.Query.#Couchbase_Lite__Query_IQuery_Explain[Explain()]` remains the same whether invoked by an app, or `cblite` -- see <<csharp:query-troubleshooting:::qe-output>> for an example of how it looks.

[#csharp:query-troubleshooting:::qe-output]
.Query.explain() Output
====

[source, console]
----
SELECT fl_result(fl_value(_doc.body, 'domains')) FROM kv_default AS _doc WHERE (_doc.flags & 1 = 0) GROUP BY fl_value(_doc.body, 'country') ORDER BY fl_value(_doc.body, 'country'), fl_value(_doc.body, 'name') // <.>

7|0|0| SCAN TABLE kv_default AS _doc // <.>
12|0|0| USE TEMP B-TREE FOR GROUP BY
52|0|0| USE TEMP B-TREE FOR ORDER BY

{"GROUP_BY":[[".country"]],"ORDER_BY":[[".country"],[".name"]],"WHAT":[[".domains"]]} // <.>

----

====

This output (<<csharp:query-troubleshooting:::qe-output>>) comprises three main elements:

<.> The translated SQL-query, which is not necessarily useful, being aimed more at Couchbase support and-or engineering teams.
<.> The _SQLite_ query plan, which gives a high-level view of how the SQL query will be implemented.
You can use this to identify potential issues and so optimize problematic queries.
<.> The query in JSON-string format, which you can copy-and-paste directly into the _cblite_ tool.


[discrete#csharp:query-troubleshooting:::the-query-plan]
=== The Query Plan


[discrete#csharp:query-troubleshooting:::format]
==== Format
The query plan section of the output displays a tabular form of the translated query's execution plan.
It primarily shows how the data will be retrieved and, where appropriate, how it will be sorted for navigation and-or presentation purposes.
For more on SQLite's Explain Query Plan -- see: https://www.sqlite.org/eqp.html

[#csharp:query-troubleshooting:::qry-plan]
.A Query Plan
====
[source, console]
----
7|0|0| SCAN TABLE kv_default AS _doc // <.>
12|0|0| USE TEMP B-TREE FOR GROUP BY // <.>
52|0|0| USE TEMP B-TREE FOR ORDER BY // <.>
----

<.> *Retrieval method* -- This line shows the retrieval method being used for the query; here a sequential read of the database.
Something you may well be looking to optimize -- see <<csharp:query-troubleshooting:::ret-method>> for more.
<.> *Grouping method* --- This line shows that the *Group By* clause used in the query requires the data to be sorted and that a b-tree will be used for temporary storage -- see <<csharp:query-troubleshooting:::order-group>>.
<.> *Ordering method* -- This line shows that the *Order By* clause used in the query requires the data to be sorted and that a b-tree will be used for temporary storage -- see <<csharp:query-troubleshooting:::order-group>>.
====


[discrete#csharp:query-troubleshooting:::ret-method]
==== Retrieval Method
The query optimizer will attempt to retrieve the requested data items as efficiently as possible, which generally will be by using one or more of the available indexes.
The _retrieval method_ shows the approach decided upon by the optimizer -- see <<csharp:query-troubleshooting:::ret-meths>>.

[#ret-meths]
.Retrieval methods
[#csharp:query-troubleshooting:::ret-meths#,cols="2,8"]
|===
|Retrieval Method | Description

|Search
|Here the query is able to access the required data directly using keys into the index.
Queries using the Search mode are the fastest.

|Scan Index
|Here the query is able to retrieve the data by scanning all or part-of the index (for example when seeking to match values within a range).
This type of query is slower than search, but at least benefits from the compact and ordered form of the index.

|Scan Table
|Here the query must scan the database table(s) to retrieve the required data.
It is the slowest of these methods and will benefit most from some form of optimization.
|===

When looking to optimize a query's retrieval method, consider whether:

* Providing an additional index makes sense
* You could use an existing index -- perhaps by restructuring the query to minimize wildcard use, or the reliance on functions that modify the query's interpretation of index keys (for example, 'lower')
* You could reduce the data set being requested to minimize the query's footprint on the database

[discrete#csharp:query-troubleshooting:::order-group]
==== Order and Group
The `Use temp b-tree for` lines in the example indicate that the query requires sorting to cater for grouping and then sorting again to present the output results.
Minimizing, if not eliminating, this ordering and re-ordering will obviously reduce the amount of time taken to process your query.

Ask "is the grouping and-or ordering absolutely necessary?": if it isn't, drop it or modify it to minimize its impact.


[discrete#csharp:query-troubleshooting:::queries-and-indexes]
=== Queries and Indexes

Querying documents using a pre-existing database index is much faster because an index narrows down the set of documents to examine -- see: the xref:csharp:query-troubleshooting.adoc[Query Troubleshooting] topic.

When planning the indexes you need for your database, remember that while indexes make queries faster, they may also:

* Make writes slightly slower, because each index must be updated whenever a document is updated
* Make your Couchbase Lite database slightly larger.

Too many indexes may hurt performance.
Optimal performance depends on designing and creating the _right_ indexes to go along with your queries.

.Constraints
[NOTE]
Couchbase Lite for net does not currently support partial value indexes; indexes with non-property expressions.
You should only index with properties that you plan to use in the query.


The Query optimizer converts your query into a parse tree that groups zero or more _and-connected_ clauses together (as dictated by your `where` conditionals) for effective query engine processing.

Ideally a query will be be able to satisfy its requirements entirely by either directly accessing the index or searching sequential index rows.
Less good is if the query must scan the whole index; although the compact nature of most indexes means this is still much faster than the alternative of scanning the entire database with no help from the indexes at all.

Searches that begin with or rely upon an inequality with the primary key are inherently less effective than those using a primary key equality.


[discrete#csharp:query-troubleshooting:::working-with-the-query-optimizer]
=== Working with the Query Optimizer
You may have noticed that sometimes a query runs faster on a second run, or after re-opening the database, or after deleting and recreating an index.
This typically happens when SQL Query Optimizer has gathered sufficient stats to recognize a means of optimizing a sub-optimal query.

If only those stats were available from the start.
In fact they are gathered after certain events, such as:

* Following index creation
* On a database close
* When running a database compact.

So, if your analysis of the <<csharp:query-troubleshooting:::qe-output,Query Explain output>> indicates a sub-optimal query and your rewrites fail to sufficiently optimize it, consider compacting the database.
Then re-generate the Query Explain and note any improvements in optimization.
They may not, in themselves, resolve the issue entirely; but they can provide a uesful guide toward further optimizing changes you could make.


[discrete#csharp:query-troubleshooting:::use-like-based-queries]
=== Wildcard and Like-based Queries

Like-based searches can use the index(es) only if:

* The search-string doesn't start with a wildcard
* The primary search expression uses a property that is indexed key
* The search-string is a constant known at run time) (that is, not a value derived during processing of the query)

To illustrate this we can use a modified query from the Mobile Travel Sample application; replacing a simple equality test with a 'LIKE'

In <<csharp:query-troubleshooting:::like-wild-pfx-qry>> we use a wildcard prefix and suffix.
You can see that the query plan decides on a retrieval method of `Scan Table`.

TIP: For more on indexes -- see: xref:csharp:indexing.adoc[Indexing]

[#like-wild-pfx-qry]
.Like with Wildcard Prefix


// Show Main Snippet
// include::csharp:example$code_snippets/Program.cs[tags="query-explain-like", indent=0]
[sourc#csharp:query-troubleshooting:::like-wild-pfx-qrye, C#]
----
using var query =
  QueryBuilder
    .Select(SelectResult.All())
    .From(DataSource.Collection(collection))
    .Where(Expression.Property("type").Like(Expression.String("%hotel%"))
      .And(Function.Lower(Expression.Property("name")).Like(Expression.String("%royal%")))); // <.>
Console.WriteLine(query.Explain());
----


<.> The indexed property, TYPE, cannot use its index because of the wildcard prefix.


.Resulting Query Plan
[source, console]
----
2|0|0| SCAN TABLE kv_default AS _doc
----

By contrast, by removing the wildcard prefix `%` (in <<csharp:query-troubleshooting:::like-no-wild-pfx-qry>>), we see that the query plan's retrieval method changes to become an index search.
Where practical, simple changes like this can make significant differences in query performance.

.Like with No Wildcard-prefix
[#like-no-wild-pfx-qry]


[#csharp:query-troubleshooting:::like-no-wild-pfx-qry]
====


// Show Main Snippet
// include::csharp:example$code_snippets/Program.cs[tags="query-explain-nopfx", indent=0]
[source, C#]
----
using var query =
  QueryBuilder
    .Select(SelectResult.All())
    .From(DataSource.Collection(collection))
    .Where(Expression.Property("type").Like(Expression.String("hotel%"))
      .And(Function.Lower(Expression.Property("name")).Like(Expression.String("%royal%")))); // <.>

Console.WriteLine(query.Explain());
----


====

<.> Simply removing the wildcard prefix enables the query optimizer to access the `typeIndex`, which results in a more efficient search.

.Resulting Query Plan
[source, bash]
----
3|0|0| SEARCH TABLE kv_default AS _doc USING INDEX typeIndex (<expr>>? AND <expr><?)
----

[discrete#csharp:query-troubleshooting:::use-functions-wisely]
=== Use Functions Wisely

Functions are a very useful tool in building queries, but be aware that they can impact whether the query-optimizer is able to use your index(es).

For example, you can observe a similar situation to that shown in <<csharp:query-troubleshooting:::use-like-based-queries>> when using the `https://docs.couchbase.com/mobile/{version-maintenance-net}/couchbase-lite-net/api/Couchbase.Lite.Query.Function.html#Couchbase_Lite_Query_Function_Lower_Couchbase_Lite_Query_IExpression_[Lower()]` function on an indexed property.

.Query
[#use-like-based-queries]


// Show Main Snippet
// include::csharp:example$code_snippets/Program.cs[tags="query-explain-function", indent=0]
[sourc#csharp:query-troubleshooting:::use-like-based-queriese, C#]
----
using var query =
  QueryBuilder
    .Select(SelectResult.All())
    .From(DataSource.Collection(collection))
    .Where(Function.Lower(Expression.Property("type")).EqualTo(Expression.String("hotel"))); // <.>

Console.WriteLine(query.Explain());
----


<.> Here we use the `https://docs.couchbase.com/mobile/{version-maintenance-net}/couchbase-lite-net/api/Couchbase.Lite.Query.Function.html#Couchbase_Lite_Query_Function_Lower_Couchbase_Lite_Query_IExpression_[Lower()]` function in the _Where_ expression

.Query Plan:
[source, bash]
----
2|0|0| SCAN TABLE kv_default AS _doc
----


But removing the `https://docs.couchbase.com/mobile/{version-maintenance-net}/couchbase-lite-net/api/Couchbase.Lite.Query.Function.html#Couchbase_Lite_Query_Function_Lower_Couchbase_Lite_Query_IExpression_[Lower()]` function, changes things:

.Query


// Show Main Snippet
// include::csharp:example$code_snippets/Program.cs[tags="query-explain-nofunction", indent=0]
[source, C#]
----
using var query =
  QueryBuilder
    .Select(SelectResult.All())
    .From(DataSource.Collection(collection))
    .Where(Expression.Property("type").EqualTo(Expression.String("hotel"))); // <.>

Console.WriteLine(query.Explain());
----


<.> Here we have removed `https://docs.couchbase.com/mobile/{version-maintenance-net}/couchbase-lite-net/api/Couchbase.Lite.Query.Function.html#Couchbase_Lite_Query_Function_Lower_Couchbase_Lite_Query_IExpression_[Lower()]` from the _Where_ expression

.Query plan
----
3|0|0| SEARCH TABLE kv_default AS _doc USING INDEX typeIndex (<expr>=?)
----

Knowing this, you can consider how you create the index; for example, using https://docs.couchbase.com/mobile/{version-maintenance-net}/couchbase-lite-net/api/Couchbase.Lite.Query.Function.html#Couchbase_Lite_Query_Function_Lower_Couchbase_Lite_Query_IExpression_[Lower()] when you create the index and then always using lowercase comparisons.

[discrete#csharp:query-troubleshooting:::optimization-considerations]
=== Optimization Considerations

Try to minimize the amount of data retrieved.
Reduce it down to the few properties you really *do* need to achieve the required result.

Consider fetching details _lazily_.
You could break complex queries into components.
Returning just the doc-ids, then process the array of doc-ids using either the Document API or a query thats uses the array of doc-ids to return information.

Consider using paging to minimize the data returned when the number of results returned is expected to be high.
Getting the whole lot at once will be slow and resource intensive: Plus does anyone want to access them all in one go?
Instead retrieve batches of information at a time, perhaps using `Where` method's `limit( offset)` feature to set a starting point for each batch subsequent batch.
Although, note that using query offsets becomes increasingly less effective as the overhead of skipping a growing number of rows each time increases. You can work around this, by instead using ranges of search-key values. If the last search-key value of batch one was 'x' then that could become the starting point for your next batch and-so-on.

Optimize document size in design.
Smaller docs load more quickly.
Break your data into logical linked units.

Consider Using Full Text Search instead of complex like or regex patterns -- see xref:csharp:fts.adoc[Full Text Search]. +
{empty}


[discrete#csharp:query-troubleshooting:::related-content]
=== Related Content
++++
<div class="card-row three-column-row">
++++

[.column]
==== {empty}
.How to . . .
* xref:csharp:querybuilder.adoc[QueryBuilder]
* xref:csharp:query-n1ql-mobile.adoc[{sqlpp} for Mobile]
* xref:csharp:query-live.adoc[Live Queries]
* xref:csharp:fts.adoc[Full Text Search]


.

[discrete.colum#csharp:query-troubleshooting:::-2n]
==== {empty}
.Learn more . . .
* xref:csharp:query-n1ql-mobile-querybuilder-diffs.adoc[{sqlpp} Mobile - Querybuilder  Differences]
* xref:csharp:query-n1ql-mobile-server-diffs.adoc[{sqlpp} Mobile - {sqlpp} Server Differences]
* xref:csharp:query-resultsets.adoc[Query Resultsets]
* xref:csharp:query-troubleshooting.adoc[Query Troubleshooting]
* xref:csharp:query-live.adoc[Live Queries]

* xref:csharp:database.adoc[Databases]
* xref:csharp:document.adoc[Documents]
* xref:csharp:blob.adoc[Blobs]

.


[discrete.colum#csharp:query-troubleshooting:::-3n]
==== {empty}
.Dive Deeper . . .
https://forums.couchbase.com/c/mobile/14[Mobile Forum] |
https://blog.couchbase.com/[Blog] |
https://docs.couchbase.com/tutorials/[Tutorials]

.


++++
</div>
++++

// block-related-content-query.adoc invoked in common module

// END -- page -- <module>-query-trouble-shooting.adoc


= Search

