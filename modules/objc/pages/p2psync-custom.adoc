:docname: p2psync-custom
:page-module: objc
:page-relative-src-path: p2psync-custom.adoc
:page-origin-url: https://github.com/couchbase/docs-couchbase-lite.git
:page-origin-start-path:
:page-origin-refname: antora-assembler-simplification
:page-origin-reftype: branch
:page-origin-refhash: (worktree)
[#objc:p2psync-custom:::]
==== Integrate Custom Listener
:page-aliases: learn/objc-p2psync-custom.adoc
ifdef::show_edition[:page-edition: {release}] {enterprise}
:page-role:
:description: Couchbase Lite database peer-to-peer sync- integrate a custom built listener



// BEGIN -- inclusion -- {module-partials}_define_module_attributes.adoc
//  Usage:  Here we define module specific attributes. It is invoked during the compilation of a page,
//          making all attributes available for use on the page.
//  UsedBy: ROOT:partial$_std_cbl_hdr.adoc

// BEGIN::module page attributes

//
// CBL-Obj-C Maintenance release number
//
:maintenance: 1
//

// VECTOR SEARCH attributes
//



// BEGIN - Set attributes pointing to API references for this module


// API Reference Links
//
//



// Supporting Data Type Classes



// DATABASE CLASSES


// Docuument Class




// Begin -- DatabaseConfiguration
// End -- DatabaseConfiguration

//Database.SAVE



//Database.DELETE


//Database.COMPACT
// deprecated 2.8
//
// :url-api-method-database-compact: https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-ios}{empty}/couchbase-lite-objc/Classes/CBLDatabase.html#/c:objc(cs)CBLDatabase(im)compact:[CBLDatabase.compact()]






// QUERY RELATED CLASSES and METHODS

// Result Classes and Methods




// Query class and methods





// Expression class and methods
// :url-api-references-query-classes: https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-ios}{empty}/couchbase-lite-objc/Classes/[Query Class index]


// ArrayFunction class and methods


// Function class and methods
//

// Where class and methods
//
// https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-ios}{empty}/couchbase-lite-objc/Classes/CBLWhere.html
// NOT SET[Where]

// orderby class and methods
//
// https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-ios}{empty}/couchbase-lite-objc/Classes/CBLOrderBy.html

// GroupBy class and methods
//
// https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-ios}{empty}/couchbase-lite-objc/Classes/CBLGroupBy.html
// NOT SET[GroupBy]

// URLEndpointConfiguration





















// diag: Env+Module objc


// Replicator API











// Note there is a replicator.status property AND
// a ReplicationStatus class/struct --- oh yes, easy to confuse.

//:url-api-property-replicator-status-activity: https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-ios}{empty}/couchbase-lite-objc/Classes/CBLReplicator.html#/s:18CouchbaseLiteobjc10ReplicatorC13ActivityLevelO







// ReplicatorConfiguration API











// Begin Replicator Retry Config
// End Replicator Retry Config


// :url-api-prop-replicator-config-ServerCertificateVerificationMode: https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-ios}{empty}/couchbase-lite-objc/Classes/CBLReplicatorConfiguration.html#/c:objc(cs)CBLReplicatorConfiguration(py)serverCertificateVerificationMode[serverCertificateVerificationMode]

// :url-api-enum-replicator-config-ServerCertificateVerificationMode: https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-ios}{empty}/couchbase-lite-objc/Classes/CBLReplicatorConfiguration.html{Enums/ServerCertificateVerificationMode.html[serverCertificateVerificationMode enum]








// Meta API




// BEGIN Logs and logging references
// :url-api-class-logging: https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-ios}{empty}/couchbase-lite-objcLogging.html[CBLLogging classes]







// END  Logs and logging references

// End define module specific attributes

// BEGIN::module page attributes
// :snippet-p2psync-ws: {snippets-p2psync-ws--objc}
// END::Local page attributes

// include::ROOT:partial$_show_page_header_block.adoc[]
// :param-name: kotlin
// :param-title: Android
// :param-module: android

// = Custom Peer-to-Peer Synchronization
// This is the 2.7 content covering Couchbase Lite P2P

[abstract]
--
Description -- _{description}_ +
Related Content -- xref:objc:p2psync-websocket.adoc[Peer-to-Peer]
--

[discrete#objc:p2psync-custom:::overview]
===== Overview

.Enterprise Edition only
IMPORTANT: Peer-to-Peer Synchronization is an https://www.couchbase.com/products/editions[Enterprise Edition] feature.
You must purchase the Enterprise License, which includes official https://www.couchbase.com/support-policy[Couchbase Support].
To use it in production (also see the https://www.couchbase.com/licensing-and-support-faq[FAQ]).

This content covers how to integrate a custom __MessageEndpointListener__ solution with Couchbase Lite to handle the data transfer, which is the sending and receiving of data.
Where applicable, we discuss how to integrate Couchbase Lite into the workflow.

The following sections describe a typical Peer-to-Peer workflow.

[discrete#objc:p2psync-custom:::peer-discovery]
===== Peer Discovery

Peer discovery is the first step.
The communication framework will generally include a Peer discovery API for devices to advertise themselves on the network and to browse for other Peers.

image::couchbase-lite/current/_images/discovery.png[]

[discrete#objc:p2psync-custom:::active-peer]
====== Active Peer

The first step is to initialize the Couchbase Lite database.

[discrete#objc:p2psync-custom:::passive-peer]
====== Passive Peer

In addition to initializing the database, the Passive Peer must initialize the `MessageEndpointListener`.
The `MessageEndpointListener` acts as a Listener for incoming connections.

[source]
----
CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"mydb" error:&error];

CBLMessageEndpointListenerConfiguration *config =
[[CBLMessageEndpointListenerConfiguration alloc] initWithCollections:[NSArray arrayWithObject:[database defaultCollection:&error]]
                                                     protocolType:kCBLProtocolTypeMessageStream];
_messageEndpointListener = [[CBLMessageEndpointListener alloc] initWithConfig:config];
----


[discrete#objc:p2psync-custom:::peer-selection-and-connection-setup]
===== Peer Selection and Connection Setup


Once a Peer device is found, the application code must decide whether it should establish a connection with that Peer.
This step includes inviting a Peer to a session and Peer authentication.

This is handled by the Communication Framework.

image::couchbase-lite/current/_images/selection.png[]

Once the remote Peer has been authenticated, the next step is to connect with that Peer and initialize the Message Endpoint API.


[discrete#objc:p2psync-custom:::replication-setup]
===== Replication Setup


image::couchbase-lite/current/_images/connection.png[]

[discrete#objc:p2psync-custom:::active-peer-2]
====== Active Peer

When the connection is established, the active Peer must instantiate a `MessageEndpoint` object corresponding to the remote Peer.

[source]
----
CBLDatabase *database = [[CBLDatabase alloc] initWithName:@"dbname" error:&error];
CBLCollection *collection = [database defaultCollection:&error];

// The delegate must implement the `CBLMessageEndpointDelegate` protocol.
NSString *id = @"";
CBLMessageEndpoint *endpoint = [[CBLMessageEndpoint alloc] initWithUID:@"UID:123"
                                                                target:id
                                                          protocolType:kCBLProtocolTypeMessageStream
                                                              delegate:self];
----

The `MessageEndpoint` initializer takes the following arguments.

. `uid`: a unique ID that represents the remote active Peer.
. `target`: This represents the remote passive Peer and could be any suitable representation of the remote Peer.
It could be an Id, URL etc.
If using the MultiPeerConnectivity Framework, this could be the MCPeerID.
. `protocolType`: specifies the kind of transport you intend to implement.
There are two options.
 ** The default (`MessageStream`) means that you want to "send a series of messages", or in other words the Communication Framework will control the formatting of messages so that there are clear boundaries between messages.
 ** The alternative (`ByteStream`) means that you just want to send raw bytes over the stream and Couchbase should format for you to ensure that messages get delivered in full.
+
Typically, the Communication Framework will handle message assembly and disassembly so you would use the `MessageType` option in most cases.

. `delegate`: the delegate that will implement the `MessageEndpointDelegate` protocol, which is a factory for `MessageEndpointConnection`.

Then, a `Replicator` is instantiated with the initialized `MessageEndpoint` as the target.

[source]
----
CBLReplicatorConfiguration *replConfig = [[CBLReplicatorConfiguration alloc]
                                      initWithTarget:endpoint];
[replConfig addCollection:collection config:nil];


// Create the replicator object.
CBLReplicator *replicator = [[CBLReplicator alloc] initWithConfig:replConfig];
[replicator start];
----

Next, Couchbase Lite will call back the application code through the `MessageEndpointDelegate.createConnection` interface method.
When the application receives the callback, it must create an instance of `MessageEndpointConnection` and return it.

[source]
----
- (id<CBLMessageEndpointConnection>)createConnectionForEndpoint:(CBLMessageEndpoint *)endpoint {
    return [[ActivePeerConnection alloc] init];
}
----

Next, Couchbase Lite will call back the application code through the `MessageEndpointConnection.open` method.

[source]
----
/* implementation of CBLMessageEndpointConnection */
- (void)open:(nonnull id<CBLReplicatorConnection>)connection completion:(nonnull void (^)(BOOL, CBLMessagingError  *_Nullable))completion {
    _replicatorConnection = connection;
    completion(YES, nil);
}
----

The connection argument is then set on an instance variable.
The application code must keep track of every `ReplicatorConnection` associated with every `MessageEndpointConnection`.

The `MessageError` argument in the completion block specifies whether the error is recoverable or not.
If it is a recoverable error, the replicator will begin a retry process, creating a new `MessageEndpointConnection` instance.

[discrete#objc:p2psync-custom:::passive-peer-2]
====== Passive Peer

After connection establishment on the Passive Peer, the first step is to initialize a new `MessageEndpointConnection` and pass it to the listener.
This message tells the listener to accept incoming data from that Peer.

[source]
----
PassivePeerConnection *connection = [[PassivePeerConnection alloc] init]; /* implements CBLMessageEndpointConnection */
[_messageEndpointListener accept:connection];
----

`messageEndpointListener` is the instance of the `MessageEndpointListener` that was created in the first step (<<objc:p2psync-custom:::peer-discovery,Peer Discovery>>)

Couchbase Lite will call the application code back through the `MessageEndpointConnection.open` method.

[source]
----
/* implementation of CBLMessageEndpointConnection */
- (void)open:(nonnull id<CBLReplicatorConnection>)connection completion:(nonnull void (^)(BOOL, CBLMessagingError *_Nullable))completion {
    _replicatorConnection = connection;
    completion(YES, nil);
}
----

The `connection` argument is then set on an instance variable.
The application code must keep track of every `ReplicatorConnection` associated with every `MessageEndpointConnection`.

At this point, the connection is established, and both Peers are ready to exchange data.



[discrete#objc:p2psync-custom:::pushpull-replication]
===== Push/Pull Replication

Typically, an application needs to send data and receive data.
The directionality of the replication could be any of the following.

* *Push only:* The data is pushed from the local database to the remote database.

* *Pull only:* The data is pulled from the remote database to the local database.

* *Push and Pull:* The data is exchanged both ways.

Usually, the remote is a Sync Gateway database identified through a URL.
In Peer-to-Peer syncing, the remote is another Couchbase Lite database.

image::couchbase-lite/current/_images/replication.png[]

The replication lifecycle is handled through the `MessageEndpointConnection`.

[discrete#objc:p2psync-custom:::active-peer-3]
====== Active Peer

When Couchbase Lite calls back the application code through the `MessageEndpointConnection.send` method, you should send that data to the other Peer using the communication framework.

[source]
----
/* implementation of CBLMessageEndpointConnection */
- (void)send:(nonnull CBLMessage *)message completion:(nonnull void (^)(BOOL, CBLMessagingError  *_Nullable))completion {
    NSData *data = [message toData];
    NSLog(@"%@", data);
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(YES, nil);
}
----

Once the data is sent, call the completion block to acknowledge the completion.
You can use the `MessageError` in the completion block to specify whether the error is recoverable.
If it is a recoverable error, the replicator will begin a retry process, creating a new `MessageEndpointConnection`.


When data is received from the passive Peer via the Communication Framework, you call the `ReplicatorConnection.receive` method.

[source]
----
CBLMessage *message = [CBLMessage fromData:data];
[_replicatorConnection receive:message];
----

The replication connection's `receive` method is called. Which then processes the data to persist to the local database.

[discrete#objc:p2psync-custom:::passive-peer-3]
====== Passive Peer

As in the case of the active Peer, the passive Peer must implement the `MessageEndpointConnection.send` method to send data to the other Peer.

[source]
----
/* implementation of CBLMessageEndpointConnection */
- (void)send:(nonnull CBLMessage *)message completion:(nonnull void (^)(BOOL, CBLMessagingError *_Nullable))completion {
    NSData *data = [message toData];
    NSLog(@"%@", data);
    /* send the data to the other peer */
    /* ... */
    /* call the completion handler once the message is sent */
    completion(YES, nil);
}
----

Once the data is sent, call the completion block to acknowledge the completion.
You can use the `MessageError` in the completion block to specify whether the error is recoverable.
If it is a recoverable error, the replicator will begin a retry process, creating a new `MessageEndpointConnection`.

When data is received from the active Peer via the Communication Framework, you call the `ReplicatorConnection.receive` method.

[source]
----
CBLMessage *message = [CBLMessage fromData:data];
[_replicatorConnection receive:message];
----


[discrete#objc:p2psync-custom:::connection-teardown]
===== Connection Teardown

When a Peer disconnects from a Peer-to-Peer network, all connected Peers are notified.
The disconnect notification is a good opportunity to close and remove a replication connection.
The steps to Teardown the connection are slightly different depending on whether the active or passive Peer disconnects first.
We will cover each case below.

[discrete#objc:p2psync-custom:::initiated-by-active-peer]
====== Initiated by Active Peer

image::couchbase-lite/current/_images/dis-active.png[]

[discrete#objc:p2psync-custom:::active-peer-4]
====== Active Peer

When an active Peer disconnects, it must call the `ReplicatorConnection.close` method.

[source]
----
[_replicatorConnection close:nil];
----

Then, Couchbase Lite will call back your code through the `MessageEndpointConnection.close` to allow the application to disconnect with the Communication Framework.

[source]
----
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
----

[discrete#objc:p2psync-custom:::passive-peer-4]
====== Passive Peer

When the passive Peer receives the corresponding disconnect notification from the Communication Framework, it must call the `ReplicatorConnection.close` method.

[source]
----
[_replicatorConnection close:nil];
----

Then, Couchbase Lite will call back your code through the `MessageEndpointConnection.close` to allow the application to disconnect with the Communication Framework.

[source]
----
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
----

[discrete#objc:p2psync-custom:::initiated-by-passive-peer]
====== Initiated by Passive Peer

image::couchbase-lite/current/_images/dis-passive.png[]

[discrete#objc:p2psync-custom:::passive-peer-5]
====== Passive Peer

When the passive disconnects, it must class the `MessageEndpointListener.closeAll` method.

[source]
----
[_messageEndpointListener closeAll];
----

Then, Couchbase Lite will call back your code through the `MessageEndpointConnection.close` to allow the application to disconnect with the Communication Framework.

[source]
----
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
----

[discrete#objc:p2psync-custom:::active-peer-5]
====== Active Peer

When the active Peer receives the corresponding disconnect notification from the Communication Framework, it must call the `ReplicatorConnection.close` method.

[source]
----
[_replicatorConnection close:nil];
----

Then, Couchbase Lite will call back your code through the `MessageEndpointConnection.close` to allow the application to disconnect with the Communication Framework.

[source]
----
/* implementation of CBLMessageEndpointConnection */
- (void)close:(nullable NSError *)error completion:(nonnull void (^)(void))completion {
    /* disconnect with communications framework */
    /* ... */
    /* call completion handler */
    completion();
}
----


// inclusion
//:param-how: //:param-reference: reference-deploy




[discrete#objc:p2psync-custom:::related-content]
===== Related Content
++++
<div class="card-row three-column-row">
++++

[.column]
====== {empty}
.How to
* xref:objc:p2psync-websocket-using-passive.adoc[Passive Peer]
* xref:objc:p2psync-websocket-using-active.adoc[Active Peer]


.

[discrete.colum#objc:p2psync-custom:::-2n]
====== {empty}
.Concepts
* xref:objc:landing-p2psync.adoc[Peer-to-Peer Sync]

* https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-ios}{empty}/couchbase-lite-objc[API References]

.


[.column]
// [.content]
[discrete#objc:p2psync-custom:::-3]
====== {empty}
.Community Resources ...
//* Community
https://forums.couchbase.com/c/mobile/14[Mobile Forum] |
https://blog.couchbase.com/[Blog] |
https://docs.couchbase.com/tutorials/[Tutorials]


.
xref:tutorials:cbl-p2p-sync-websockets:swift/cbl-p2p-sync-websockets.adoc[Getting Started with Peer-to-Peer Synchronization]




++++
</div>
++++


