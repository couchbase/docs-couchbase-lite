:docname: document
:page-module: android
:page-relative-src-path: document.adoc
:page-origin-url: https://github.com/couchbase/docs-couchbase-lite.git
:page-origin-start-path:
:page-origin-refname: antora-assembler-simplification
:page-origin-reftype: branch
:page-origin-refhash: (worktree)
[#android:document:::]
= Documents
:page-aliases: documents.adoc, learn/java-android-document.adoc
:page-toclevels: 2@
:page-role:
:description: Couchbase Lite concepts -- Data model -- Documents


[abstract]
--
Description -- _{description}_ +
Related Content -- xref:android:database.adoc[Databases] | xref:android:blob.adoc[Blobs] | xref:android:indexing.adoc[Indexing] |
--


[#android:document:::overview]
== Overview


[#android:document:::document-structure]
=== Document Structure

In pass:q,a[_pass:q,a[pass:q,a[Couchbase{nbsp}Lite]]_] the term 'document' refers to an entry in the database.
You can compare it to a record, or a row in a table.

Each document has an ID or unique identifier.
This ID is similar to a primary key in other databases.

You can specify the ID programmatically.
If you omit it, it will be automatically generated as a UUID.

NOTE: Couchbase documents are assigned to a <<android:database:::database-concepts,Collection>>.
The ID of a document must be unique within the Collection it is written to.
You cannot change it after you have written the document.

The document also has a value which contains the actual application data.
This value is stored as a dictionary of key-value (k-v) pairs.
The values can be made of up several different <<android:document:::data-types>> such as numbers, strings, arrays, and nested objects.


[#android:document:::data-encoding]
=== Data Encoding

The document body is stored in an internal, efficient, binary form called
https://github.com/couchbaselabs/fleece#readme[Fleece].
This internal form can be easily converted into a manageable native dictionary format for manipulation in applications.

Fleece data is stored in the smallest format that will hold the value whilst maintaining the integrity of the value.


[discrete#android:document:::fleece-data-encoding
== Fleece data encoding

When working with Android-Java, the Fleece encoding cycle can result in the Java type information being lost.
Therefore care should be taken with non-explicit functions such as `toArray()` or `toMap()`,
when storing and recovering data in a document,
or converting that document to JSON and back.

Always use explicit creation of the expected type, whenever the type of result is not itself explicit. For example:

[tabs]
=====

Java::
+
--
[source, Java, indent=0]
----
            Document doc = collection.getDocument(someDoc.getId());
            // force longVal to be type Long, even if it could be represented as an int.
            long longVal = doc.getLong("test");
----
--


Kotlin::
+
--
[source, Kotlin, indent=0]
----
        val doc = collection.getDocument (someDoc.id)
        // force longVal to be type Long, even if it could be represented as an Int.
        val longVal = doc?.getLong(("test"))
----
--
=====

Similarly, interpreting data not stored as `boolean` as a boolean value can give inconsistent results.


[#android:document:::data-types]
=== Data Types

The `Document` class offers a set of property accessors for various scalar types, such as:

* Boolean
* Date
* Double
* Float
* Int
* Long
* String

These accessors take care of converting to/from JSON encoding, and make sure you get the type you expect.

In addition to these basic data types Couchbase Lite provides for the following:

Dictionary:: represents a read-only key-value pair collection
MutableDictionary:: represents a writeable key-value pair collection
Array:: represents a readonly ordered collection of objects
MutableArray:: represents a writeable collection of objects
Blob:: represents an arbitrary piece of binary data


[#android:document:::json]
=== JSON

Couchbase Lite also provides for the direct handling of JSON data implemented in most cases by the provision of a pass:a,q[`toJSON()`] method on appropriate API classes (for example, on MutableDocument, Dictionary, Blob and Array) -- see <<android:document:::lbl-json-data>>.


[#android:document:::constructing-a-document]
== Constructing a Document


An individual document often represents a single instance of an object in application code.

You can consider a document as the equivalent of a 'row' in a relational table,
with each of the document's attributes being equivalent to a 'column'.

Documents can contain nested structures.
This allows developers to express many-to-many relationships without requiring a reference or join table,
and is naturally expressive of hierarchical data.

Most apps will work with one or more documents, persisting them to a local database and optionally syncing them, either centrally or to the cloud.

In this section we provide an example of how you might create a `hotel` document, which provides basic contact details and price data.

.Data Model
[source]
----

hotel: {
  type: string (value = `hotel`)
  name: string
  address: dictionary {
    street: string
    city: string
    state: string
    country: string
    code: string
  }
  phones: array
  rate: float
}

----

[#android:document:::ex-usage]
=== Open a Database

First open your database.
If the database does not already exist, Couchbase Lite will create it for you.

Couchbase documents are assigned to a <<android:database:::database-concepts,Collection>>.
All the CRUD examples in this document operate on a `collection` object (here, the Default Collection).


[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="datatype_usage_createdb", indent=0]
[source, Kotlin]
----
// Initialize the Couchbase Lite system
CouchbaseLite.init(context)

// Get the database (and create it if it doesn’t exist).
val database = Database("getting-started")
val collection = database.getCollection("myCollection")
    ?: throw IllegalStateException("collection not found")

----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="datatype_usage_createdb", indent=0]

Java::
+
--
[source, Java]
----
// Get the database (and create it if it doesn’t exist).
Database database = new Database("getting-started");
try (Collection collection = database.getCollection("myCollection")) {
    if (collection == null) { throw new IllegalStateException("collection not found"); }

----
--

=====


See xref:android:database.adoc[Databases] for more information

[#android:document:::create-a-document]
=== Create a Document

Now create a new document to hold your application's data.

Use the mutable form, so that you can add data to the document.


[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="datatype_usage_createdoc", indent=0]
[source, Kotlin]
----
// Create your new document
val mutableDoc = MutableDocument()

----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="datatype_usage_createdoc", indent=0]

Java::
+
--
[source, Java]
----
// Create your new document
MutableDocument mutableDoc = new MutableDocument();

----
--

=====


For more on using *Documents*, see <<android:document:::document-initializers>> and <<android:document:::mutability>>.

[#android:document:::create-a-dictionary]
=== Create a Dictionary

Now create a mutable dictionary (`address`).

Each element of the dictionary value will be directly accessible via its own key.


[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="datatype_usage_mutdict", indent=0]
[source, Kotlin]
----
// Create a new mutable dictionary and populate some keys/values
val address = MutableDictionary()
address.setString("street", "1 Main st.")
address.setString("city", "San Francisco")
address.setString("state", "CA")
address.setString("country", "USA")
address.setString("code", "90210")

----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="datatype_usage_mutdict", indent=0]

Java::
+
--
[source, Java]
----
// Create a new mutable dictionary and populate some keys/values
MutableDictionary address = new MutableDictionary();
address.setString("street", "1 Main st.");
address.setString("city", "San Francisco");
address.setString("state", "CA");
address.setString("country", "USA");
address.setString("code", "90210");

----
--

=====


Learn more about <<android:document:::using-dictionaries>>.

[#android:document:::create-an-array]
=== Create an Array

Since the hotel may have multiple contact numbers, provide a field (`phones`) as a mutable array.


[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="datatype_usage_mutarray", indent=0]
[source, Kotlin]
----
// Create and populate mutable array
val phones = MutableArray()
phones.addString("650-000-0000")
phones.addString("650-000-0001")

----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="datatype_usage_mutarray", indent=0]

Java::
+
--
[source, Java]
----
// Create and populate mutable array
MutableArray phones = new MutableArray();
phones.addString("650-000-0000");
phones.addString("650-000-0001");

----
--

=====


Learn more about <<android:document:::using-arrays>>

[#android:document:::populate-a-document]
=== Populate a Document

Now add your data to the mutable document created earlier.
Each data item is stored as a key-value pair.


[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="datatype_usage_populate", indent=0]
[source, Kotlin]
----
// Initialize and populate the document

// Add document type to document properties <.>
mutableDoc.setString("type", "hotel")

// Add hotel name string to document properties <.>
mutableDoc.setString("name", "Hotel Java Mo")

// Add float to document properties <.>
mutableDoc.setFloat("room_rate", 121.75f)

// Add dictionary to document's properties <.>
mutableDoc.setDictionary("address", address)

// Add array to document's properties <.>
mutableDoc.setArray("phones", phones)

----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="datatype_usage_populate", indent=0]

Java::
+
--
[source, Java]
----
// Initialize and populate the document

// Add document type to document properties <.>
mutableDoc.setString("type", "hotel");

// Add hotel name string to document properties <.>
mutableDoc.setString("name", "Hotel Java Mo");

// Add float to document properties <.>
mutableDoc.setFloat("room_rate", 121.75F);

// Add dictionary to document's properties <.>
mutableDoc.setDictionary("address", address);

// Add array to document's properties <.>
mutableDoc.setArray("phones", phones);

----
--

=====


NOTE: Couchbase recommend using a `type` attribute to define each logical document type.


[#android:document:::save-a-document]
=== Save a Document

Now persist the populated document to your Couchbase Lite database.
This will auto-generate the document id.


[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="datatype_usage_persist", indent=0]
[source, Kotlin]
----
// Save the document changes <.>
collection.save(mutableDoc)

----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="datatype_usage_persist", indent=0]

Java::
+
--
[source, Java]
----
// Save the document changes <.>
collection.save(mutableDoc);
----
--

=====


[#android:document:::close-the-database]
=== Close the Database

With your document saved, you can now close our Couchbase Lite database.


[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="datatype_usage_closedb", indent=0]
[source, Kotlin]
----
// Close the database <.>
database.close()

----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="datatype_usage_closedb", indent=0]

Java::
+
--
[source, Java]
----
// Close the database <.>
database.close();

----
--

=====


[#android:document:::working-with-data]
== Working with Data


[#android:document:::checking-a-documents-properties]
=== Checking a Document's Properties

To check whether a given property exists in the document, use the https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-android}{empty}/couchbase-lite-android/com/couchbase/lite/Document.html#contains-java.lang.String-[`Document.Contains(String key)] method.

If you try to access a property which doesn't exist in the document, the call will return the default value for that getter method (0 for https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-android}{empty}/couchbase-lite-android/com/couchbase/lite/Document.html#getInt-java.lang.String-[Document.getInt()] 0.0 for https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-android}{empty}/couchbase-lite-android/com/couchbase/lite/Document.html#getFloat-java.lang.String-[Document.getFloat()] etc.).

.Fleece data encoding
[NOTE]
--
Care should be taken when storing and recovering data in a document or converting that document to JSON and back. +
Data encoding (Fleece) can result in `Long` values being converted to `Integers`, and `Double` values to `Float`. +
Interpreting data as boolean can also give inconsistent results.
--


[#android:document:::date-accessors]
=== Date accessors

Couchbase Lite offers _Date_ accessors as a convenience.
Dates are a common data type, but JSON doesn't natively support them, so the convention is to store them as strings in ISO-8601 format.

.Date Getter
[#ex-date-getter]


[#android:document:::ex-date-getter]
====

pass:q,a[This example sets the date on the `createdAt` property and reads it back using the https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-android}{empty}/couchbase-lite-android/com/couchbase/lite/Document.html#getDate-java.lang.String-[Document.getDate()] accessor method.]
[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="date-getter", indent=0]
[source, Kotlin]
----
doc.setValue("createdAt", Date())
val date = doc.getDate("createdAt")
----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="date-getter", indent=0]

Java::
+
--
[source, Java]
----
newTask.setValue("createdAt", new Date());
Date date = newTask.getDate("createdAt");
----
--

=====


====


[#android:document:::using-dictionaries]
=== Using Dictionaries

.API References

* https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-android}{empty}/couchbase-lite-android/com/couchbase/lite/Dictionary.html[Dictionary]

* https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-android}{empty}/couchbase-lite-android/com/couchbase/lite/MutableDictionary.html[MutableDictionary]


.Read Only
[#ex-dict]


[#android:document:::ex-dict]
====

[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="datatype_dictionary", indent=0]
[source, Kotlin]
----
// NOTE: No error handling, for brevity (see getting started)
val document = collection.getDocument("doc1")

// Getting a dictionary from the document's properties
val dict = document?.getDictionary("address")

// Access a value with a key from the dictionary
val street = dict?.getString("street")

// Iterate dictionary
dict?.forEach { println("${it} -> ${dict.getValue(it)}") }

// Create a mutable copy
val mutableDict = dict?.toMutable()

----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="datatype_dictionary", indent=0]

Java::
+
--
[source, Java]
----
// NOTE: No error handling, for brevity (see getting started)
Document document = collection.getDocument("doc1");
if (document == null) { return; }

// Getting a dictionary from the document's properties
Dictionary dict = document.getDictionary("address");
if (dict == null) { return; }

// Access a value with a key from the dictionary
String street = dict.getString("street");

// Iterate dictionary
for (String key: dict.getKeys()) {
    System.out.println("Key " + key + " = " + dict.getValue(key));
}

// Create a mutable copy
MutableDictionary mutableDict = dict.toMutable();

----
--

=====


====


.Mutable
[#ex-mutdict]


[#android:document:::ex-mutdict]
====

[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="datatype_mutable_dictionary", indent=0]
[source, Kotlin]
----
// NOTE: No error handling, for brevity (see getting started)

// Create a new mutable dictionary and populate some keys/values
val mutableDict = MutableDictionary()
mutableDict.setString("street", "1 Main st.")
mutableDict.setString("city", "San Francisco")

// Add the dictionary to a document's properties and save the document
val mutableDoc = MutableDocument("doc1")
mutableDoc.setDictionary("address", mutableDict)
collection.save(mutableDoc)

----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="datatype_mutable_dictionary", indent=0]

Java::
+
--
[source, Java]
----
// NOTE: No error handling, for brevity (see getting started)

// Create a new mutable dictionary and populate some keys/values
MutableDictionary mutableDict = new MutableDictionary();
mutableDict.setString("street", "1 Main st.");
mutableDict.setString("city", "San Francisco");

// Add the dictionary to a document's properties and save the document
MutableDocument mutableDoc = new MutableDocument("doc1");
mutableDoc.setDictionary("address", mutableDict);
collection.save(mutableDoc);

----
--

=====


====


[#android:document:::using-arrays]
=== Using Arrays

.API References
* https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-android}{empty}/couchbase-lite-android/com/couchbase/lite/Array.html[Array]

* https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-android}{empty}/couchbase-lite-android/com/couchbase/lite/MutableArray.html[MutableArray]

.Read Only
[#ex-array]


[#android:document:::ex-array]
====

[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="datatype_array", indent=0]
[source, Kotlin]
----
// NOTE: No error handling, for brevity (see getting started)

val document = collection.getDocument("doc1")

// Getting a phones array from the document's properties
val array = document?.getArray("phones")

// Get element count
val count = array?.count()

// Access an array element by index
val phone = array?.getString(1)

// Iterate array
array?.forEachIndexed { index, item -> println("Row  ${index} = ${item}") }

// Create a mutable copy
val mutableArray = array?.toMutable()
----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="datatype_array", indent=0]

Java::
+
--
[source, Java]
----
// NOTE: No error handling, for brevity (see getting started)

Document document = collection.getDocument("doc1");
if (document == null) { return; }

// Getting a phones array from the document's properties
Array array = document.getArray("phones");
if (array == null) { return; }

// Get element count
int count = array.count();

// Access an array element by index
String phone = array.getString(1);

// Iterate array
for (int i = 0; i < count; i++) {
    System.out.println("Row  " + i + " = " + array.getString(i));
}

// Create a mutable copy
MutableArray mutableArray = array.toMutable();
----
--

=====


====


.Mutable
[#ex-mutarray]


[#android:document:::ex-mutarray]
====

[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="datatype_mutable_array", indent=0]
[source, Kotlin]
----
// NOTE: No error handling, for brevity (see getting started)

// Create a new mutable array and populate data into the array
val mutableArray = MutableArray()
mutableArray.addString("650-000-0000")
mutableArray.addString("650-000-0001")

// Set the array to document's properties and save the document
val mutableDoc = MutableDocument("doc1")
mutableDoc.setArray("phones", mutableArray)
collection.save(mutableDoc)
----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="datatype_mutable_array", indent=0]

Java::
+
--
[source, Java]
----
// NOTE: No error handling, for brevity (see getting started)

// Create a new mutable array and populate data into the array
MutableArray mutableArray = new MutableArray();
mutableArray.addString("650-000-0000");
mutableArray.addString("650-000-0001");

// Set the array to document's properties and save the document
MutableDocument mutableDoc = new MutableDocument("doc1");
mutableDoc.setArray("phones", mutableArray);
collection.save(mutableDoc);
----
--

=====


====


[#android:document:::using-blobs]
=== Using Blobs

For more on working with blobs, see xref:android:blob.adoc[Blobs]


[#android:document:::document-initializers]
== Document Initializers


You can use the following methods/initializers:

* Use the https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-android}{empty}/couchbase-lite-android/com/couchbase/lite/MutableDocument.html#s:18CouchbaseLiteSwift15MutableDocumentMutableDocument--[MutableDocument()] initializer to create a new document where the document ID is randomly generated by the database.

* Use the https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-android}{empty}/couchbase-lite-android/com/couchbase/lite/MutableDocument.html#s:18CouchbaseLiteSwift15MutableDocument}MutableDocument-java.lang.String-[MutableDocument(String id)] initializer to create a new document with a specific ID.

* Use the {url-api-method-collection-getdocument} method to get a document.
If the document doesn't exist in the collection, the method will return `null`.
You can use this behavior to check if a document with a given ID already exists in the collection.


.Persist a document
[#ex-persists-doc]


[#android:document:::ex-persists-doc]
====

pass:q,a[The following code example creates a document and persists it to the database.]
[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="initializer", indent=0]
[source, Kotlin]
----
val doc = MutableDocument()
doc.let {
    it.setString("type", "task")
    it.setString("owner", "todo")
    it.setDate("createdAt", Date())
}
collection.save(doc)
----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="initializer", indent=0]

Java::
+
--
[source, Java]
----
MutableDocument newTask = new MutableDocument();
newTask.setString("type", "task");
newTask.setString("owner", "todo");
newTask.setDate("createdAt", new Date());
collection.save(newTask);
----
--

=====


====


[#android:document:::mutability]
== Mutability


By default, a document is immutable when it is read from the database.
Use the https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-android}{empty}/couchbase-lite-android/com/couchbase/lite/Document.html#toMutable--[`Document.toMutable()] to create an updatable instance of the document.


.Make a mutable document
[#ex-update-doc]


[#android:document:::ex-update-doc]
====

pass:q,a[Changes to the document are persisted to the database when the `save` method is called.]
[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="update-document", indent=0]
[source, Kotlin]
----
collection.getDocument("xyz")?.toMutable()?.let {
    it.setString("name", "apples")
    collection.save(it)
}
----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="update-document", indent=0]

Java::
+
--
[source, Java]
----
MutableDocument mutableDocument = collection.getDocument("xyz").toMutable();
mutableDocument.setString("name", "apples");
collection.save(mutableDocument);
----
--

=====


====


NOTE: Any user change to the value of reserved keys (`_id`, `_rev` or `_deleted`) will be detected when a document is saved and will result in an exception (Error Code 5 -- `CorruptRevisionData`) -- see also <<android:document:::lbl-doc-constraints>>.


[#android:document:::batch-operations]
== Batch operations

If you're making multiple changes to a database at once, it's faster to group them together.
The following example persists a few documents in batch.

.Batch operations
[#ex-batch-ops]


[#android:document:::ex-batch-ops]
====

[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="batch", indent=0]
[source, Kotlin]
----
database.inBatch(UnitOfWork {
    for (i in 0..9) {
        val doc = MutableDocument()
        doc.let {
            it.setValue("type", "user")
            it.setValue("name", "user $i")
            it.setBoolean("admin", false)
        }
        log("saved user document: ${doc.getString("name")}")
    }
})
----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="batch", indent=0]

Java::
+
--
[source, Java]
----
database.inBatch(() -> {
    for (int i = 0; i < 10; i++) {
        MutableDocument doc = new MutableDocument();
        doc.setValue("type", "user");
        doc.setValue("name", "user " + i);
        doc.setBoolean("admin", false);
        collection.save(doc);
    }
});
----
--

=====


====


At the *local* level this operation is still transactional: no other `Database` instances, including ones managed by the replicator can make changes during the execution of the block, and other instances will not see partial changes.
But Couchbase Mobile is a distributed system, and due to the way replication works, there's no guarantee that Sync Gateway or other devices will receive your changes all at once.


[#android:document:::document-change-events]
== Document change events

You can register for document changes.
The following example registers for changes to the document with ID `user.john` and prints the `verified_account` property when a change is detected.


.Document change events
[#ex-doc-events]


[#android:document:::ex-doc-events]
====

[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="document-listener", indent=0]
[source, Kotlin]
----
collection.addDocumentChangeListener("user.john") { change ->
    collection.getDocument(change.documentID)?.let {
        log("Status: ${it.getString("verified_account")}")
    }
}
----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="document-listener", indent=0]

Java::
+
--
[source, Java]
----
collection.addDocumentChangeListener(
    "user.john",
    change -> {
        String docId = change.getDocumentID();
        try {
            Document doc = collection.getDocument(docId);
            if (doc != null) {
                Logger.log("Status: " + doc.getString("verified_account"));
            }
        }
        catch (CouchbaseLiteException e) {
            Logger.log("Failed getting doc : " + docId);
        }
    });
----
--

=====


====


[#android:document:::using-kotlin-flows-and-livedata]
=== Using Kotlin Flows and LiveData

Kotlin users can also take advantage of Flows and LiveData to monitor for changes.

The following methods show how to watch for document changes in a given database or for changes to a specific document.

[tabs]
=====

Database Changes::
+
--
[source, Kotlin, subs="attributes+"]
----
        return collection.collectionChangeFlow(null)
            .map { it.documentIDs }
            .asLiveData()
----
--


Document Changes::
+
--
[source, Kotlin, subs="attributes+"]
----
        return collection.documentChangeFlow("1001")
            .mapNotNull { change ->
                change.takeUnless {
                    collection.getDocument(it.documentID)?.getString("owner").equals(owner)
                }
            }
            .asLiveData()
----
--
=====


[#android:document:::document-expiration]
== Document Expiration

Document expiration allows users to set the expiration date for a document.
When the document expires, it is purged from the database.
The purge is not replicated to Sync Gateway.

.Set document expiration
[#ex-set-doc-exp]


[#android:document:::ex-set-doc-exp]
====

This example sets the TTL for a document to 1 day from the current time.
[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="document-expiration", indent=0]
[source, Kotlin]
----
// Purge the document one day from now
collection.setDocumentExpiration(
    "doc123",
    Date(System.currentTimeMillis() + (1000 * 60 * 60 * 24))
)

// Reset expiration
collection.setDocumentExpiration("doc1", null)

// Query documents that will be expired in less than five minutes
val query = QueryBuilder
    .select(SelectResult.expression(Meta.id))
    .from(DataSource.collection(collection))
    .where(
        Meta.expiration.lessThan(
            Expression.longValue(System.currentTimeMillis() + (1000 * 60 * 5))
        )
    )
----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="document-expiration", indent=0]

Java::
+
--
[source, Java]
----
// Purge the document one day from now
Instant ttl = Instant.now().plus(1, ChronoUnit.DAYS);
collection.setDocumentExpiration("doc123", new Date(ttl.toEpochMilli()));

// Reset expiration
collection.setDocumentExpiration("doc1", null);

// Query documents that will be expired in less than five minutes
Instant fiveMinutesFromNow = Instant.now().plus(5, ChronoUnit.MINUTES);
Query query = QueryBuilder
    .select(SelectResult.expression(Meta.id))
    .from(DataSource.collection(collection))
    .where(Meta.expiration.lessThan(Expression.doubleValue(fiveMinutesFromNow.toEpochMilli())));
----
--

=====


====


You can set expiration for a whole Collection

[#android:document:::lbl-doc-constraints]
== Document Constraints

Couchbase Lite APIs do not explicitly disallow the use of attributes with the underscore prefix at the top level of document.
This is to facilitate the creation of documents for use either in _local only_ mode where documents are not synced, or when used exclusively in peer-to-peer sync.

NOTE: "_id", :"_rev" and "_sequence" are reserved keywords and must not be used as top-level attributes -- see <<android:document:::res-keys>>.

Users are cautioned that any attempt to sync such documents to Sync Gateway will result in an error.
To be future proof, you are advised to avoid creating such documents.
Use of these attributes for user-level data may result in undefined system behavior.

For more guidance -- see: xref:sync-gateway:ROOT:data-modeling.adoc[Sync Gateway - data modeling guidelines]

[#android:document:::res-keys]
.Reserved Keys List
====

* _attachments

* _deleted footnote:fn1[Any change to this reserved key will be detected when it is saved and will result in a Couchbase exception (Error Code 5 -- `CorruptRevisionData`)]

* _id footnote:fn1[]

* _removed

* _rev footnote:fn1[]

* _sequence
====


[#android:document:::lbl-json-data]
== Working with JSON Data

In this section::
<<android:document:::lbl-array>>
| <<android:document:::lbl-blob>>
| <<android:document:::lbl-dictionary>>
| <<android:document:::lbl-document>>
| <<android:document:::lbl-result>>


The pass:a,q[`toJSON()`] typed-accessor means you can easily work with JSON data, native and Couchbase Lite objects.

[#android:document:::lbl-array]
=== Arrays

Convert an `ArrayObject` to and from JSON using the pass:a,q[`toJSON()`] and `toArray` methods -- see <<android:document:::ex-array>>.

Additionally you can:

* Initialize a 'MutableArrayObject' using data supplied as a JSON string.
This is done using the `init(json)` constructor -- see: <<android:document:::ex-array>>

* Convert an `ArrayFragment` object to a JSON String

* Set data with a JSON string using `setJSON()`

.Arrays as JSON strings
[#ex-array]


[#android:document:::ex-array]
====

[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="tojson-array", indent=0]
[source, Kotlin]
----
// github tag=tojson-array
val mArray = MutableArray(JSON) // <.>
for (i in 0 until mArray.count()) {
    mArray.getDictionary(i)?.apply {
        log(getString("name") ?: "unknown")
        collection.save(MutableDocument(getString("id"), toMap()))
    } // <.>
}

collection.getDocument("1002")?.getArray("features")?.apply {
    for (feature in toList()) {
        log("$feature")
    } // <.>
    log(toJSON())
} // <.>
----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="tojson-array", indent=0]

Java::
+
--
[source, Java]
----
// github tag=tojson-array
final MutableArray mArray = new MutableArray(JSON); // <.>

for (int i = 0; i < mArray.count(); i++) { // <.>
    final Dictionary dict = mArray.getDictionary(i);
    Logger.log(dict.getString("name"));
    collection.save(new MutableDocument(dict.getString("id"), dict.toMap()));
}

final Array features = collection.getDocument("1002").getArray("features");
for (Object feature: features.toList()) { Logger.log(feature.toString()); }
Logger.log(features.toJSON()); // <.>
----
--

=====


====


[#android:document:::lbl-blob]
=== Blobs
Convert a `Blob` to JSON using the `toJSON` method -- see <<android:document:::ex-blob>>.

You can use `isBlob()` to check whether a given dictionary object is a blob or not -- see <<android:document:::ex-blob>>.

Note that the blob object must first be saved to the database (generating the required metadata) before you can use the `toJSON` method.

[#ex-blob]
.Blobs as JSON strings


[#android:document:::ex-blob]
====

[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="tojson-blob", indent=0]
[source, Kotlin]
----
// github tag=tojson-blob
val thisBlob = collection.getDocument("thisdoc-id")!!.toMap()
if (!Blob.isBlob(thisBlob)) {
    return
}
val blobType = thisBlob["content_type"].toString()
val blobLength = thisBlob["length"] as Number?
----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="tojson-blob", indent=0]

Java::
+
--
[source, Java]
----
// github tag=tojson-blob
final Map<String, ?> thisBlob = collection.getDocument("thisdoc-id").toMap();
if (!Blob.isBlob(thisBlob)) { return; }

final String blobType = thisBlob.get("content_type").toString();
final Number blobLength = (Number) thisBlob.get("length");
----
--

=====


====


See also: xref:android:blob.adoc[Blobs]

[#android:document:::lbl-dictionary]
=== Dictionaries

Convert a `DictionaryObject` to and from JSON using the `toJSON` and `toDictionary` methods -- see <<android:document:::ex-dictionary>>.

Additionally you can:

* Initialize a 'MutableDictionaryObject' using data supplied as a JSON string.
This is done using the `init(json)` constructor-- see: <<android:document:::ex-dictionary>>

* Set data with a JSON string using `setJSON()`

[#ex-dictionary]
.Dictionaries as JSON strings


[#android:document:::ex-dictionary]
====

[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="tojson-dictionary", indent=0]
[source, Kotlin]
----
// github tag=tojson-dictionary
val mDict = MutableDictionary(JSON) // <.>
log("$mDict")
log("Details for: ${mDict.getString("name")}")
mDict.keys.forEach { key ->
    log(key + " => " + mDict.getValue(key))
}
----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="tojson-dictionary", indent=0]

Java::
+
--
[source, Java]
----
// github tag=tojson-dictionary
final MutableDictionary mDict = new MutableDictionary(JSON); // <.>
Logger.log(mDict.toString());

Logger.log("Details for: " + mDict.getString("name"));
for (String key: mDict.getKeys()) {
    Logger.log(key + " => " + mDict.getValue(key));
}
----
--

=====


====


[#android:document:::lbl-document]
=== Documents

Convert a `Document` to and from JSON strings using the pass:a,q[`toJSON()`] and pass:a,q[`setJSON()`] methods -- see <<android:document:::ex-document>>.

Additionally you can:

* Initialize a 'MutableDocument' using data supplied as a JSON string.
This is done using the `init(json)` or `init(id: json:)` constructor -- see: <<android:document:::ex-document>>

* Set data with a JSON string using `setJSON()`

.Documents as JSON strings
[#ex-document]


[#android:document:::ex-document]
====

[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="query-get-all;tojson-document", indent=0]
[source, Kotlin]
----
QueryBuilder
    .select(SelectResult.expression(Meta.id).`as`("metaId"))
    .from(DataSource.collection(srcColl))
    .execute()
    .forEach {
        it.getString("metaId")?.let { thisId ->
            srcColl.getDocument(thisId)?.toJSON()?.let { json -> // <.>
                log("JSON String = $json")
                val hotelFromJSON = MutableDocument(thisId, json) // <.>
                dstColl.save(hotelFromJSON)
                dstColl.getDocument(thisId)?.toMap()?.forEach { e ->
                    log("$e.key => $e.value")
                } // <.>
            }
        }
    }
----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="query-get-all;tojson-document", indent=0]

Java::
+
--
[source, Java]
----
// github tag=tojson-document
final Query listQuery = QueryBuilder
    .select(SelectResult.expression(Meta.id).as("metaId"))
    .from(DataSource.collection(srcColl));

try (ResultSet results = listQuery.execute()) {
    for (Result row: results) {
        final String thisId = row.getString("metaId");

        final String json = srcColl.getDocument(thisId).toJSON(); // <.>
        Logger.log("JSON String = " + json);

        final MutableDocument hotelFromJSON = new MutableDocument(thisId, json); // <.>

        dstColl.save(hotelFromJSON);

        for (Map.Entry<String, Object> entry: dstColl.getDocument(thisId).toMap().entrySet()) {
            Logger.log(entry.getKey() + " => " + entry.getValue()); // <.>
        }
    }
}
----
--

=====


====


[#android:document:::lbl-result]
=== Query Results as JSON

Convert a `Query Result` to JSON using its {to-JSON} accessor method.

[#ex-json]
.Using JSON Results


[#android:document:::ex-json]
====

pass:q,a[Use https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-android}{empty}/couchbase-lite-android/com/couchbase/lite/Result.html#toJSON--[Result.toJSON()] to transform your result string into a JSON string, which can easily be serialized or used as required in your application. See <<android:document:::ex-json>> for a working example.]
[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
// include::android:example$codesnippet_collection.kt[tags="query-access-json", indent=0]
[source, Kotlin]
----
// Uses Jackson JSON processor
val mapper = ObjectMapper()
val hotels = mutableListOf<Hotel>()

listQuery.execute().use { rs ->
    rs.forEach {

        // Get result as JSON string
        val json = it.toJSON() // <.>

        // Get Hashmap from JSON string
        val dictFromJSONstring = mapper.readValue(json, HashMap::class.java) // <.>

        // Use created hashmap
        val hotelId = dictFromJSONstring["id"].toString() //
        val hotelType = dictFromJSONstring["type"].toString()
        val hotelname = dictFromJSONstring["name"].toString()

        // Get custom object from JSON string
        val thisHotel = mapper.readValue(json, Hotel::class.java) // <.>
        hotels.add(thisHotel)
    }
}
----

--
// Show Optional Alternate Snippet
// include::android:example$codesnippet_collection.java[tags="query-access-json", indent=0]

Java::
+
--
[source, Java]
----
        ObjectMapper mapper = new ObjectMapper();
        ArrayList<Hotel> hotels = new ArrayList<>();
        HashMap<String, Object> dictFromJSONstring;

        try (ResultSet resultSet = listQuery.execute()) {
            for (Result result: resultSet) {

                // Get result as JSON string
                String thisJsonString = result.toJSON(); // <.>

                // Get Java  Hashmap from JSON string
                dictFromJSONstring =
                    mapper.readValue(thisJsonString, HashMap.class); // <.>


                // Use created hashmap
                String hotelId = dictFromJSONstring.get("id").toString();
                String hotelType = dictFromJSONstring.get("type").toString();
                String hotelname = dictFromJSONstring.get("name").toString();


                // Get custom object from Native 'dictionary' object
                Hotel thisHotel =
                    mapper.readValue(thisJsonString, Hotel.class); // <.>
                hotels.add(thisHotel);
            }
        }
        // Uses Jackson JSON processor
        ObjectMapper mapper = new ObjectMapper();
        List<Hotel> hotels = new ArrayList<>();

        try (ResultSet rs = listQuery.execute()) {
            for (Result result: rs) {
                String json = result.toJSON();
                Map<String, String> dictFromJSONstring = mapper.readValue(json, HashMap.class);

                String hotelId = dictFromJSONstring.get("id");
                String hotelType = dictFromJSONstring.get("type");
                String hotelname = dictFromJSONstring.get("name");

                // Get custom object from JSON string
                Hotel thisHotel = mapper.readValue(json, Hotel.class);
                hotels.add(thisHotel);
            }
        }
    }

    public List<Map<String, Object>> docsOnlyQuerySyntaxN1QL(Database thisDb) throws CouchbaseLiteException {
        // For Documentation -- N1QL Query using parameters
        //  Declared elsewhere: Database thisDb
        Query thisQuery =
            thisDb.createQuery(
                "SELECT META().id AS thisId FROM _ WHERE type = \"hotel\""); // <.>
        List<Map<String, Object>> results = new ArrayList<>();
        try (ResultSet rs = thisQuery.execute()) {
            for (Result result: rs) { results.add(result.toMap()); }
        }
        return results;
    }

    public List<Map<String, Object>> docsonlyQuerySyntaxN1QLParams(Database thisDb) throws CouchbaseLiteException {
        // For Documentation -- N1QL Query using parameters
        //  Declared elsewhere: Database thisDb

        Query thisQuery =
            thisDb.createQuery(
                "SELECT META().id AS thisId FROM _ WHERE type = $type"); // <.

        thisQuery.setParameters(
            new Parameters().setString("type", "hotel")); // <.>

        List<Map<String, Object>> results = new ArrayList<>();
        try (ResultSet rs = thisQuery.execute()) {
            for (Result result: rs) { results.add(result.toMap()); }
        }
        return results;
    }
}

//
// Copyright (c) 2023 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.codesnippets;

import androidx.annotation.NonNull;

import java.net.URI;
import java.net.URISyntaxException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.cert.X509Certificate;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import com.couchbase.codesnippets.utils.Logger;
import com.couchbase.lite.BasicAuthenticator;
import com.couchbase.lite.Collection;
import com.couchbase.lite.CollectionConfiguration;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.DatabaseEndpoint;
import com.couchbase.lite.DocumentFlag;
import com.couchbase.lite.Endpoint;
import com.couchbase.lite.ListenerToken;
import com.couchbase.lite.ReplicatedDocument;
import com.couchbase.lite.Replicator;
import com.couchbase.lite.ReplicatorConfiguration;
import com.couchbase.lite.ReplicatorProgress;
import com.couchbase.lite.ReplicatorStatus;
import com.couchbase.lite.ReplicatorType;
import com.couchbase.lite.SessionAuthenticator;
import com.couchbase.lite.URLEndpoint;


@SuppressWarnings({"unused"})
public class ReplicationExamples {
    private Replicator thisReplicator;
    private ListenerToken thisToken;

    public void activeReplicatorExample(Set<Collection> collections)
        throws URISyntaxException {
        // Create replicator
        // Consider holding a reference somewhere
        // to prevent the Replicator from being GCed
        Replicator repl = new Replicator( // <.>

            // initialize the replicator configuration
            new ReplicatorConfiguration(new URLEndpoint(new URI("wss://listener.com:8954"))) // <.>
                .addCollections(collections, null)

                // Set replicator type
                .setType(ReplicatorType.PUSH_AND_PULL)

                // Configure Sync Mode
                .setContinuous(false) // default value


                // set auto-purge behavior
                // (here we override default)
                .setAutoPurgeEnabled(false) // <.>


                // Configure Server Authentication --
                // only accept self-signed certs
                .setAcceptOnlySelfSignedServerCertificate(true) // <.>

                // Configure the credentials the
                // client will provide if prompted
                .setAuthenticator(new BasicAuthenticator("Our Username", "Our Password".toCharArray())) // <.>

        );

        // Optionally add a change listener <.>
        ListenerToken token = repl.addChangeListener(change -> {
            CouchbaseLiteException err = change.getStatus().getError();
            if (err != null) { Logger.log("Error code :: " + err.getCode(), err); }
        });

        // Start replicator
        repl.start(false); // <.>


        thisReplicator = repl;
        thisToken = token;

    }

    public void replicatorSimpleExample(Set<Collection> collections) throws URISyntaxException {
        Endpoint theListenerEndpoint
            = new URLEndpoint(new URI("wss://10.0.2.2:4984/db")); // <.>

        ReplicatorConfiguration thisConfig =
            new ReplicatorConfiguration(theListenerEndpoint) // <.>
                .addCollections(collections, null) // default configuration

                .setAcceptOnlySelfSignedServerCertificate(true) // <.>
                .setAuthenticator(new BasicAuthenticator(
                    "valid.user",
                    "valid.password".toCharArray())); // <.>

        Replicator repl = new Replicator(thisConfig); // <.>
        // Start the replicator
        repl.start(); // <.>
        // (be sure to hold a reference somewhere that will prevent it from being GCed)
        thisReplicator = repl;

    }

    public void replicationBasicAuthenticationExample(
        Set<Collection> collections,
        CollectionConfiguration collectionConfig)
        throws URISyntaxException {

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        Replicator repl = new Replicator(
            new ReplicatorConfiguration(new URLEndpoint(new URI("ws://localhost:4984/mydatabase")))
                .addCollections(collections, collectionConfig)
                .setAuthenticator(new BasicAuthenticator("username", "password".toCharArray())));

        repl.start();
        thisReplicator = repl;
    }


    public void replicationSessionAuthenticationExample(
        Set<Collection> collections,
        CollectionConfiguration collectionConfig)
        throws URISyntaxException {

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        Replicator repl = new Replicator(
            new ReplicatorConfiguration(new URLEndpoint(new URI("ws://localhost:4984/mydatabase")))
                .addCollections(collections, collectionConfig)
                .setAuthenticator(new SessionAuthenticator("904ac010862f37c8dd99015a33ab5a3565fd8447")));

        repl.start();
        thisReplicator = repl;
    }

    public void replicationCustomHeaderExample(
        Set<Collection> collections,
        CollectionConfiguration collectionConfig)
        throws URISyntaxException {
        Map<String, String> headers = new HashMap<>();
        headers.put("CustomHeaderName", "Value");

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        Replicator repl = new Replicator(
            new ReplicatorConfiguration(new URLEndpoint(new URI("ws://localhost:4984/mydatabase")))
                .addCollections(collections, collectionConfig)
                .setHeaders(headers));

        repl.start();
        thisReplicator = repl;
    }

    public void replicationPushFilterExample(Set<Collection> collections) throws URISyntaxException {
        CollectionConfiguration collectionConfig = new CollectionConfiguration()
            .setPushFilter((document, flags) -> flags.contains(DocumentFlag.DELETED)); // <1>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        Replicator repl = new Replicator(
            new ReplicatorConfiguration(new URLEndpoint(new URI("ws://localhost:4984/mydatabase")))
                .addCollections(collections, collectionConfig));

        repl.start();
        thisReplicator = repl;
    }


    public void replicationPullFilterExample(Set<Collection> collections) throws URISyntaxException {
        CollectionConfiguration collectionConfig = new CollectionConfiguration()
            .setPullFilter((document, flags) -> "draft".equals(document.getString("type"))); // <1>

        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        Replicator repl = new Replicator(
            new ReplicatorConfiguration(new URLEndpoint(new URI("ws://localhost:4984/mydatabase")))
                .addCollections(collections, collectionConfig));

        repl.start();
        thisReplicator = repl;
    }

    public void replicationResetCheckpointExample(Set<Collection> collections) throws URISyntaxException {
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        Replicator repl = new Replicator(
            new ReplicatorConfiguration(new URLEndpoint(new URI("ws://localhost:4984/mydatabase")))
                .addCollections(collections, null));

        repl.start(true);

        // ... at some later time

        repl.stop();
    }

    public void handlingNetworkErrorsExample(Set<Collection> collections) throws URISyntaxException {
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        Replicator repl = new Replicator(
            new ReplicatorConfiguration(new URLEndpoint(new URI("ws://localhost:4984/mydatabase")))
                .addCollections(collections, null));

        repl.addChangeListener(change -> {
            CouchbaseLiteException error = change.getStatus().getError();
            if (error != null) { Logger.log("Error code:: " + error); }
        });
        repl.start();
        thisReplicator = repl;
    }

    public void certificatePinningExample(Set<Collection> collections, String keyStoreName, String certAlias)
        throws URISyntaxException, KeyStoreException {
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        Replicator repl = new Replicator(
            new ReplicatorConfiguration(new URLEndpoint(new URI("ws://localhost:4984/mydatabase")))
                .addCollections(collections, null)
                .setPinnedServerX509Certificate(
                    (X509Certificate) KeyStore.getInstance(keyStoreName).getCertificate(certAlias)));

        repl.start();
        thisReplicator = repl;
    }

    public void replicatorConfigExample(Set<Collection> collections) throws URISyntaxException {
        // initialize the replicator configuration
        ReplicatorConfiguration thisConfig = new ReplicatorConfiguration(
            new URLEndpoint(new URI("wss://10.0.2.2:8954/travel-sample"))) // <.>
            .addCollections(collections, null);
    }


    public void p2pReplicatorStatusExample(Replicator repl) {
        ReplicatorStatus status = repl.getStatus();
        ReplicatorProgress progress = status.getProgress();
        Logger.log(
            "The Replicator is " + status.getActivityLevel()
                + "and has processed " + progress.getCompleted()
                + " of " + progress.getTotal() + " changes");
    }


    public void p2pReplicatorStopExample(Replicator repl) {
        // Stop replication.
        repl.stop(); // <.>
    }


    public void customRetryConfigExample(Set<Collection> collections) throws URISyntaxException {
        Replicator repl = new Replicator(
            new ReplicatorConfiguration(new URLEndpoint(new URI("ws://localhost:4984/mydatabase")))
                .addCollections(collections, null)
                //  other config as required . . .
                .setHeartbeat(150) // <.>
                .setMaxAttempts(20) // <.>
                .setMaxAttemptWaitTime(600)); // <.>

        repl.start();
        thisReplicator = repl;
    }

    public void replicatorDocumentEventExample(Set<Collection> collections) throws URISyntaxException {
        // Create replicator (be sure to hold a reference somewhere that will prevent the Replicator from being GCed)
        Replicator repl = new Replicator(
            new ReplicatorConfiguration(new URLEndpoint(new URI("ws://localhost:4984/mydatabase")))
                .addCollections(collections, null));


        ListenerToken token = repl.addDocumentReplicationListener(replication -> {
            Logger.log("Replication type: " + ((replication.isPush()) ? "push" : "pull"));
            for (ReplicatedDocument document: replication.getDocuments()) {
                Logger.log("Doc ID: " + document.getID());

                CouchbaseLiteException err = document.getError();
                if (err != null) {
                    // There was an error
                    Logger.log("Error replicating document: ", err);
                    return;
                }

                if (document.getFlags().contains(DocumentFlag.DELETED)) {
                    Logger.log("Successfully replicated a deleted document");
                }
            }
        });


        repl.start();
        thisReplicator = repl;

        token.remove();
    }

    public void replicationPendingDocumentsExample(Collection collection)
        throws CouchbaseLiteException, URISyntaxException {
        Replicator repl = new Replicator(
            new ReplicatorConfiguration(new URLEndpoint(new URI("ws://localhost:4984/mydatabase")))
                .addCollection(collection, null)
                .setType(ReplicatorType.PUSH));

        Set<String> pendingDocs = repl.getPendingDocumentIds(collection);

        if (!pendingDocs.isEmpty()) {
            Logger.log("There are " + pendingDocs.size() + " documents pending");

            final String firstDoc = pendingDocs.iterator().next();

            repl.addChangeListener(change -> {
                Logger.log("Replicator activity level is " + change.getStatus().getActivityLevel());
                try {
                    if (!repl.isDocumentPending(firstDoc, collection)) {
                        Logger.log("Doc ID " + firstDoc + " has been pushed");
                    }
                }
                catch (CouchbaseLiteException err) {
                    Logger.log("Failed getting pending docs", err);
                }
            });

            repl.start();
            this.thisReplicator = repl;
        }
    }

    public void databaseReplicatorExample(@NonNull Set<Collection> srcCollections, @NonNull Database targetDb) {
        // This is an Enterprise feature:
        // the code below will generate a compilation error
        // if it's compiled against CBL Android Community Edition.
        // Note: the target database must already contain the
        //       source collections or the replication will fail.
        final Replicator repl = new Replicator(
            new ReplicatorConfiguration(new DatabaseEndpoint(targetDb))
                .addCollections(srcCollections, null)
                .setType(ReplicatorType.PUSH));

        // Start the replicator
        // (be sure to hold a reference somewhere that will prevent it from being GCed)
        repl.start();
        thisReplicator = repl;
    }

    public void replicationWithCustomConflictResolverExample(Set<Collection> srcCollections, URI targetUri) {
        Replicator repl = new Replicator(
            new ReplicatorConfiguration(new URLEndpoint(targetUri))
                .addCollections(
                    srcCollections,
                    new CollectionConfiguration()
                        .setConflictResolver(new LocalWinConflictResolver())));

        // Start the replicator
        // (be sure to hold a reference somewhere that will prevent it from being GCed)
        repl.start();
        thisReplicator = repl;
    }
}


//
// Copyright (c) 2024 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package com.couchbase.codesnippets;

import java.util.List;
import java.util.function.Function;

import com.couchbase.lite.Blob;
import com.couchbase.lite.Collection;
import com.couchbase.lite.CouchbaseLiteException;
import com.couchbase.lite.Database;
import com.couchbase.lite.IndexUpdater;
import com.couchbase.lite.MutableArray;
import com.couchbase.lite.Parameters;
import com.couchbase.lite.PredictiveModel;
import com.couchbase.lite.Query;
import com.couchbase.lite.ResultSet;
import com.couchbase.lite.VectorEncoding;
import com.couchbase.lite.VectorIndexConfiguration;


@SuppressWarnings("unused")
class VectorSearchExamples {
    @FunctionalInterface
    public interface ColorModel { List<Float> getEmbedding(Blob color);}

    public void createDefaultVSConfig() {
        // create the configuration for a vector index named "vector"
        // with 3 dimensions and 100 centroids
        VectorIndexConfiguration config = new VectorIndexConfiguration("vector", 3L, 100L);
    }

    public void createCustomVSConfig() {
        // create the configuration for a vector index named "vector"
        // with 3 dimensions, 100 centroids, no encoding, using cosine distance
        // with a max training size 5000 and amin training size 2500
        // no vector encoding and using COSINE distance measurement
        VectorIndexConfiguration config = new VectorIndexConfiguration("vector", 3L, 100L)
            .setEncoding(VectorEncoding.none())
            .setMetric(VectorIndexConfiguration.DistanceMetric.COSINE)
            .setNumProbes(8L)
            .setMinTrainingSize(2500L)
            .setMaxTrainingSize(5000L);
    }

    public void createVectorIndex(Database db) throws CouchbaseLiteException {
        // create a vector index named "colors_index"
        // in the collection "_default.colors"
        db.getCollection("colors").createIndex(
            "colors_index",
            new VectorIndexConfiguration("vector", 3L, 100L));
    }

    public void setNumProbes(Collection col) throws CouchbaseLiteException {
        // explicitly set numProbes
        col.createIndex(
            "colors_index",
            new VectorIndexConfiguration("vector", 3L, 100L)
                .setNumProbes(5));
    }

    public void createPredictiveIndex(Database db, PredictiveModel colorModel) throws CouchbaseLiteException {
        // create a vector index with a simple predictive model
        Database.prediction.registerModel("ColorModel", colorModel);

        db.getCollection("colors").createIndex(
            "colors_pred_index",
            new VectorIndexConfiguration(
                "prediction(ColorModel, {'colorInput': color}).vector",
                3L, 100L));
    }

    public void useVectorIndex(Database db, List<Object> colorVector) throws CouchbaseLiteException {
        db.getCollection("colors").createIndex(
            "colors_index",
            new VectorIndexConfiguration("vector", 3L, 100L));

        // get the APPROX_VECTOR_DISTANCE to the parameter vector for each color in the collection
        Query query = db.createQuery(
            "SELECT meta().id, color, APPROX_VECTOR_DISTANCE(vector, $vectorParam)"
                + " FROM _default.colors");
        Parameters params = new Parameters();
        params.setArray("vectorParam", new MutableArray(colorVector));
        query.setParameters(params);

        try (ResultSet rs = query.execute()) {
            // process results
        }
        // end:vs-use-vector-index[]
    }

    public void useAVD(Database db, List<Object> colorVector) throws CouchbaseLiteException {
        // use APPROX_VECTOR_DISTANCE in a query ORDER BY clause
        Query query = db.createQuery(
            "SELECT meta().id, color"
                + " FROM _default.colors"
                + " ORDER BY APPROX_VECTOR_DISTANCE(vector, $vectorParam)"
                + " LIMIT 8");
        Parameters params = new Parameters();
        params.setArray("vectorParam", new MutableArray(colorVector));
        query.setParameters(params);

        try (ResultSet rs = query.execute()) {
            // process results
        }
    }

    public void useAVDWithWhere(Database db, List<Object> colorVector) throws CouchbaseLiteException {
        // use APPROX_VECTOR_DISTANCE in a query WHERE clause
        Query query = db.createQuery(
            "SELECT meta().id, color"
                + " FROM _default.colors"
                + " WHERE APPROX_VECTOR_DISTANCE(vector, $vectorParam) < 0.5");
        Parameters params = new Parameters();
        params.setArray("vectorParam", new MutableArray(colorVector));
        query.setParameters(params);

        try (ResultSet rs = query.execute()) {
            // process results
        }
    }

    public void useAVDWithPrediction(Database db, PredictiveModel colorModel, List<Object> colorVector)
        throws CouchbaseLiteException {
        // use APPROX_VECTOR_DISTANCE with a predictive model
        Database.prediction.registerModel("ColorModel", colorModel);

        db.getCollection("colors").createIndex(
            "colors_pred_index",
            new VectorIndexConfiguration(
                "prediction(ColorModel, {'colorInput': color}).vector",
                3L, 100L));

        Query query = db.createQuery(
            "SELECT meta().id, color"
                + " FROM _default.colors"
                + " ORDER BY APPROX_VECTOR_DISTANCE("
                + "    prediction(ColorModel, {'colorInput': color}).vector,"
                + "    $vectorParam)"
                + " LIMIT 300");
        Parameters params = new Parameters();
        params.setArray("vectorParam", new MutableArray(colorVector));
        query.setParameters(params);

        try (ResultSet rs = query.execute()) {
            // process results
        }
    }

    public void hybridOrderBy(Database db, List<Object> colorVector) throws CouchbaseLiteException {
        Query query = db.createQuery(
            "SELECT meta().id, color"
                + " FROM _default.colors"
                + " WHERE saturation > 0.5"
                + " ORDER BY APPROX_VECTOR_DISTANCE(vector, $vector)"
                + " LIMIT 8");
        Parameters params = new Parameters();
        params.setArray("vectorParam", new MutableArray(colorVector));
        query.setParameters(params);

        try (ResultSet rs = query.execute()) {
            // process results
        }
    }

    public void hybridWhere(Database db, List<Object> colorVector) throws CouchbaseLiteException {
        Query query = db.createQuery(
            "SELECT meta().id, color"
                + " FROM _default.colors"
                + " WHERE saturation > 0.5"
                + "     AND APPROX_VECTOR_DISTANCE(vector, $vector) < .05");
        Parameters params = new Parameters();
        params.setArray("vectorParam", new MutableArray(colorVector));
        query.setParameters(params);

        try (ResultSet rs = query.execute()) {
            // process results
        }
    }

    public void hybridPrediction(Database db, List<Object> colorVector) throws CouchbaseLiteException {
        Query query = db.createQuery(
            "SELECT meta().id, color"
                + " FROM _default.colors"
                + " WHERE saturation > 0.5"
                + " ORDER BY APPROX_VECTOR_DISTANCE("
                + "    prediction(ColorModel, {'colorInput': color}).vector,"
                + "    $vectorParam)"
                + " LIMIT 8");
        Parameters params = new Parameters();
        params.setArray("vectorParam", new MutableArray(colorVector));
        query.setParameters(params);

        try (ResultSet rs = query.execute()) {
            // process results
        }
    }

//    ??? vs-hybrid-vmatch[]

    public void hybridFullText(Database db, List<Object> colorVector) throws CouchbaseLiteException {
        // Create a hybrid vector search query with full-text's match() that
        // uses the the full-text index named "color_desc_index".
        Query query = db.createQuery(
            "SELECT meta().id, color"
                + " FROM _default.colors"
                + " WHERE MATCH(color_desc_index, $text)"
                + " ORDER BY APPROX_VECTOR_DISTANCE(vector, $vector)"
                + " LIMIT 8");
        Parameters params = new Parameters();
        params.setArray("vectorParam", new MutableArray(colorVector));
        query.setParameters(params);

        try (ResultSet rs = query.execute()) {
            // process results
        }
    }

    public void lazyIndexConfig(Database db) throws CouchbaseLiteException {
        db.getCollection("colors").createIndex(
            "colors_index",
            new VectorIndexConfiguration("color", 3L, 100L)
                .setLazy(true));
    }

    public void lazyIndexEmbed(Collection col, ColorModel colorModel) throws CouchbaseLiteException {
        while (true) {
            try (IndexUpdater updater = col.getIndex("colors_index").beginUpdate(10)) {
                if (updater == null) { break; }
                for (int i = 0; i < updater.count(); i++) {
                    // get the color swatch from the updater and send it to the remote model
                    List<Float> embedding = colorModel.getEmbedding(updater.getBlob(i));
                    if (embedding != null) { updater.setVector(embedding, i); }
                    else {
                        // Bad connection? Corrupted over the wire? Something bad happened
                        // and the vector cannot be generated at the moment: skip it.
                        // The next time beginUpdate() is called, we'll try it again.
                        updater.skipVector(i);
                    }
                }
                // This writes the vectors to the index. You MUST either have set or skipped each
                // of the the vectors in the updater or this call will throw an exception.
                updater.finish();
            }
        }
    }
}

----
--

=====


====


.JSON String Format
[#android:document:::ex-json-format]
If your query selects ALL then the JSON format will be:

[source, JSON]
----
{
  database-name: {
    key1: "value1",
    keyx: "valuex"
  }
}
----

If your query selects a sub-set of available properties then the JSON format will be:

[source, JSON]
----
{
  key1: "value1",
  keyx: "valuex"
}
----


[#android:document:::related-content]
== Related Content
++++
<div class="card-row three-column-row">
++++

[.column]
=== {empty}
.How to . . .
* xref:android:gs-prereqs.adoc[Prerequisites]
* xref:android:gs-install.adoc[Install]
* xref:android:gs-build.adoc[Build and Run]


.

[discrete.colum#android:document:::-2n]
=== {empty}
.Learn more . . .
* xref:android:database.adoc[Databases]
* xref:android:document.adoc[Documents]
* xref:android:blob.adoc[Blobs]
* xref:android:replication.adoc[Remote Sync Gateway]
* xref:android:conflict.adoc[Handling Data Conflicts]

.


[discrete.colum#android:document:::-3n]
=== {empty}
.Dive Deeper . . .
https://forums.couchbase.com/c/mobile/14[Mobile Forum] |
https://blog.couchbase.com/[Blog] |
https://docs.couchbase.com/tutorials/[Tutorials]

.


++++
</div>
++++

:page-toclevels: 2

