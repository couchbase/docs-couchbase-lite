:docname: conflict
:page-module: android
:page-relative-src-path: conflict.adoc
:page-origin-url: https://github.com/couchbase/docs-couchbase-lite.git
:page-origin-start-path:
:page-origin-refname: antora-assembler-simplification
:page-origin-reftype: branch
:page-origin-refhash: (worktree)
[#android:conflict:::]
== Handling Data Conflicts
:page-aliases: learn/java-android-conflict.adoc
:page-role:
:description: Couchbase Lite Database Sync -- Handling conflict between data changes

// Define our environment

// Present common content including abstract and related content footer blocks
// BEGIN -- inclusion -- common-conflict.adoc
//  Location: ROOT:partial$commons/common-
//  Params:
//    :no-footer: define to suppress output of the
//                related content footer when not using tags
//  Used-by:  android-conflict.adoc files


// // DO NOT EDIT
[abstract]
--
Description -- _{description}_ +
--
// DO NOT EDIT

[discrete#android:conflict:::causes-of-conflicts]
=== Causes of Conflicts

Document conflicts can occur if multiple changes are made to the same version of a document by multiple peers in a distributed system. For Couchbase Mobile, this can be a Couchbase Lite or Sync Gateway database instance.

Such conflicts can occur after either of the following events:

* *A replication saves a document change* -- in which case the change with the _most-revisions wins_ (unless one change is a delete). See the example <<android:conflict:::lbl-conflicts-when-replicating,Case 1: Conflicts when a replication is in progress>>
* *An application saves a document change directly to a database instance* -- in which case, _last write wins_, unless one change is a delete -- see <<android:conflict:::conflicts-when-saving,Case 2: Conflicts when saving a document>>

NOTE: *_Deletes_ always win.* So, in either of the above cases, if one of the changes was a _Delete_ then that change wins.

The following sections discuss each scenario in more detail.

[TIP]
.Dive deeper ...
Read more about link:https://blog.couchbase.com//document-conflicts-couchbase-mobile[Document Conflicts and Automatic Conflict Resolution in Couchbase Mobile].

[discrete#android:conflict:::lbl-conflicts-when-replicating]
=== Conflicts when Replicating

There's no practical way to prevent a conflict when incompatible changes to a document are be made in multiple instances of an app.
The conflict is realized only when replication propagates the incompatible changes to each other.
anchor:bmkRepConScene[A typical replication conflict scenario]

.A typical cause of replication conflicts:
====
. Molly uses her device to create _DocumentA_.
. Replication syncs _DocumentA_ to Naomi's device.
. Molly uses her device to apply _ChangeX_ to _DocumentA_.
. Naomi uses her device to make a different change, _ChangeY_, to _DocumentA_.
. Replication syncs _ChangeY_ to Molly's device.
+
This device already has _ChangeX_ putting the local document in conflict.
. Replication syncs _ChangeX_ to Naomi's device.
+
This device already has _ChangeY_ and now Naomi's local document is in conflict.
====

[discrete#android:conflict:::automatic-conflict-resolution]
==== Automatic Conflict Resolution

NOTE: The rules only apply to conflicts caused by replication.
Conflict resolution takes place exclusively during pull replication, while push replication remains unaffected.

Couchbase Lite uses the following rules to handle conflicts such as those described in <<android:conflict:::bmkRepConScene>>:

* If one of the changes is a deletion:
+
A deleted document (that is, a _tombstone_) always wins over a document update.
* If both changes are document changes:
+
The change with the most revisions will win.
+
Since each change creates a revision with an ID prefixed by an incremented version number, the winner is the change with the highest version number.

The result is saved internally by the Couchbase Lite replicator.
Those rules describe the internal behavior of the replicator.
For additional control over the handling of conflicts, including when a replication is in progress, see <<android:conflict:::custom-conflict-resolution>>.

[discrete#android:conflict:::custom-conflict-resolution]
==== Custom Conflict Resolution

Starting in Couchbase Lite 2.6, application developers who want more control over how document conflicts are handled can use custom logic to select the winner between conflicting revisions of a document.

If a custom conflict resolver is not provided, the system will automatically resolve conflicts as discussed in <<android:conflict:::automatic-conflict-resolution,Automatic Conflict Resolution>>, and as a consequence there will be no conflicting revisions in the database.

CAUTION: While this is true of any user defined functions, app developers must be strongly cautioned against writing sub-optimal custom conflict handlers that are time consuming and could slow down the client's save operations.

To implement custom conflict resolution during replication, you must implement the following steps.

. <<android:conflict:::conflict-resolver,Conflict Resolver>>
. <<android:conflict:::configure-the-replicator,Configure the Replicator>>

[discrete#android:conflict:::conflict-resolver]
==== Conflict Resolver

Apps have the following strategies for resolving conflicts:

- *Local Wins:* The current revision in the database wins.
- *Remote Wins:* The revision pulled from the remote endpoint through replication wins.
- *Merge:* Merge the content bodies of the conflicting revisions.

// tag::handling-conflicts-conflict-resolvers[]
.Using conflict resolvers
====
// :is-android:
[tabs]
======


Kotlin::
+

[tabs]
=====

Local Wins::
+
--

[source, Kotlin]
----

// Using replConfig.setConflictResolver(new LocalWinConflictResolver());
@Suppress("unused")
object LocalWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.localDocument
}

----
--


Remote Wins::
+
--

[source, Kotlin]
----

// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
@Suppress("unused")
object RemoteWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.remoteDocument
}

----

--


Merge::
+
--

[source, Kotlin]
----

// Using replConfig.setConflictResolver(new MergeConflictResolver());
@Suppress("unused")
object MergeConflictResolver : ConflictResolver {
    override fun resolve(conflict: Conflict): Document {
        val localDoc = conflict.localDocument?.toMap()
        val remoteDoc = conflict.remoteDocument?.toMap()

        val merge: MutableMap<String, Any>?
        if (localDoc == null) {
            merge = remoteDoc
        } else {
            merge = localDoc
            if (remoteDoc != null) {
                merge.putAll(remoteDoc)
            }
        }

        return if (merge == null) {
            MutableDocument(conflict.documentId)
        } else {
            MutableDocument(conflict.documentId, merge)
        }
    }

----


--
=====

Java::
+
[tabs]
=====

Local Wins::
+
--
[source, Java]
----
class LocalWinConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        return conflict.getLocalDocument();
    }
}
----
--


Remote Wins::
+
--
[source, Java]
----
// Using replConfig.setConflictResolver(new RemoteWinConflictResolver());
@Suppress("unused")
object RemoteWinsResolver : ConflictResolver {
    override fun resolve(conflict: Conflict) = conflict.remoteDocument
}
----
--


Merge::
+
--
[source, Java]
----
class MergeConflictResolver implements ConflictResolver {
    public Document resolve(Conflict conflict) {
        Map<String, Object> merge = conflict.getLocalDocument().toMap();
        merge.putAll(conflict.getRemoteDocument().toMap());
        return new MutableDocument(conflict.getDocumentId(), merge);
    }
}
----
--
=====
======
====
// end::handling-conflicts-conflict-resolvers[]

When a null document is returned by the resolver, the conflict will be resolved as a document deletion.


[discrete#android:conflict:::important-guidelines-and-best-practices]
==== Important Guidelines and Best Practices

.Points of Note:
* If you have multiple replicators, it is recommended that instead of distinct resolvers, you should use a unified conflict resolver across all replicators.
Failure to do so could potentially lead to data loss under exception cases or if the app is terminated (by the user or an app crash) while there are pending conflicts.
* If the document ID of the document returned by the resolver does not correspond to the document that is in conflict then the replicator will log a warning message.
+
IMPORTANT: Developers are encouraged to review the warnings and fix the resolver to return a valid document ID.

* If a document from a different database is returned, the replicator will treat it as an error.
A <<android:conflict:::replication-events,document replication event>> will be posted with an error and an error message will be logged.
+
IMPORTANT: Apps are encouraged to observe such errors and take appropriate measures to fix the resolver function.

* When the replicator is stopped, the system will attempt to resolve outstanding and pending conflicts before stopping.
Hence apps should expect to see some delay when attempting to stop the replicator depending on the number of outstanding documents in the replication queue and the complexity of the resolver function.
* If there is an exception thrown in the `resolve()` method, the exception will be caught and handled:
** The conflict to resolve will be skipped.
// TODO: regarding the following point, does that mean the replicator is stopped when an exception is thrown?
The pending conflicted documents will be resolved when the replicator is restarted.
** The exception will be reported in the warning logs.
** The exception will be reported in the <<android:conflict:::replication-events,document replication event>>.
+
IMPORTANT: While the system will handle exceptions in the manner specified above, it is strongly encouraged for the resolver function to catch exceptions and handle them in a way appropriate to their needs.

[discrete#android:conflict:::configure-the-replicator]
==== Configure the Replicator

The implemented custom conflict resolver can be registered on the replicator configuration object.
The default value of the conflictResolver is `null`.
When the value is `null`, the default conflict resolution will be applied.

.A Conflict Resolver
[#wx-conflict-resolver]
// BEGIN inclusion -- block -- block_tabbed_code_example.adoc
//
//  Allows for abstraction of the showing of snippet examples
//  which makes displaying tabbed snippets for platforms with
//  more than one native language to show -- Android (Kotlin and Java)
//
// Surrounds code in Example block
//
//  PARAMETERS:
//    param-tags comma-separated list of tags to include/exclude
//    param-leader text for opening para of an example block
//
//  USE:
//    :param_tags: query-access-json
//    include::partial$block_show_snippet.adoc[]
//    :param_tags!:
//

[#android:conflict:::wx-conflict-resolver]
====

// inject tab header
[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
[source, Kotlin]
----
include ::android:example$codesnippet_collection.kt[tags="replication-conflict-resolver", indent=0]

val collectionConfig = CollectionConfigurationFactory.newConfig(conflictResolver = LocalWinsResolver)
val repl = Replicator(
    ReplicatorConfigurationFactory.newConfig(
        target = URLEndpoint(URI("ws://localhost:4984/mydatabase")),
        collections = mapOf(srcCollections to collectionConfig)
    )
)

// Start the replicator
// (be sure to hold a reference somewhere that will prevent it from being GCed)
repl.start()
thisReplicator = repl
----

--
// Show Optional Alternate Snippet

Java::
+
--
[source, Java]
----
include ::android:example$codesnippet_collection.java[tags="replication-conflict-resolver", indent=0]
Replicator repl = new Replicator(
    new ReplicatorConfiguration(new URLEndpoint(targetUri))
        .addCollections(
            srcCollections,
            new CollectionConfiguration()
                .setConflictResolver(new LocalWinConflictResolver())));

// Start the replicator
// (be sure to hold a reference somewhere that will prevent it from being GCed)
repl.start();
thisReplicator = repl;
----
// Add tab closure
--

=====



// close example block

====

// Tidy-up atttibutes created
// END -- block_show_snippet.doc


[discrete#android:conflict:::conflicts-when-saving]
=== Conflicts when Updating


When updating a document, you need to consider the possibility of update conflicts.
Update conflicts can occur when you try to update a document that’s been updated since you read it.


.How Updating May Cause Conflicts
====
Here's a typical sequence of events that would create an update conflict:

. Your code reads the document's current properties, and constructs a modified copy to save.
. Another thread (perhaps the replicator) updates the document, creating a new revision with different properties.
. Your code updates the document with its modified properties, for example using https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-android}{empty}/couchbase-lite-android/com/couchbase/lite/Database.html#save-com.couchbase.lite.MutableDocument-[database.save(MutableDocument document)].
====

[discrete#android:conflict:::automatic-conflict-resolution-2]
==== Automatic Conflict Resolution

In Couchbase Lite, by default, the conflict is automatically resolved and only one document update is stored in the database.
The Last-Write-Win (LWW) algorithm is used to pick the winning update.
So in effect, the changes from step 2 would be overwritten and lost.

If the probability of update conflicts is high in your app and you wish to avoid the possibility of overwritten data, the `save` and `delete` APIs provide additional method signatures with concurrency control:

.Currency Control Signatures
====
Save operations::
https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-android}{empty}/couchbase-lite-android/com/couchbase/lite/Database.html#save-com.couchbase.lite.MutableDocument-com.couchbase.lite.ConcurrencyControl-[database.save(MutableDocument document, ConcurrencyControl concurrencyControl)] -- attempts to save the document with a concurrency control.
+
The concurrency control parameter has two possible values:

* `lastWriteWins` (default): The last operation wins if there is a conflict.
* `failOnConflict`: The operation will fail if there is a conflict.
+
In this case, the app can detect the error that is being thrown, and handle it by re-reading the document, making the necessary conflict resolution, then trying again.

Delete operations::
As with save operations, delete operation also have two method signatures, which specify how to handle a possible conflict:

* https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-android}{empty}/couchbase-lite-android/com/couchbase/lite/Database.html#delete-com.couchbase.lite.Document-[database.delete(Document document)]: The last write will win if there is a conflict.
* https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-android}{empty}/couchbase-lite-android/com/couchbase/lite/Database.html#delete-com.couchbase.lite.Document-com.couchbase.lite.ConcurrencyControl-[database.delete(Document document, ConcurrencyControl concurrencyControl)]: attempts to delete the document with a concurrency control.

+
The concurrency control parameter has two possible values:
** `lastWriteWins` (default): The last operation wins if there is a conflict.
** `failOnConflict`: The operation will fail if there is a conflict.
In this case, the app can detect the error that is being thrown, and handle it by re-reading the document, making the necessary conflict resolution, then trying again.
====

[discrete#android:conflict:::custom-conflict-handlers]
==== Custom Conflict Handlers
// :no-footer:
Developers can hook a conflict handler when saving a document so they can easily handle the conflict in a single save method call.

To implement custom conflict resolution when saving a document, apps must call the `save` method with a conflict handler block ( https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-android}{empty}/couchbase-lite-android/com/couchbase/lite/Database.html#save-com.couchbase.lite.MutableDocument-com.couchbase.lite.ConflictHandler-[database.save(MutableDocument, ConflictHandler)]).

// tag::handling-conflicts-custom-merge[]
The following code snippet shows an example of merging properties from the existing document (`current`) into the one being saved (`new`).
In the event of conflicting keys, it will pick the key value from `new`.

.Merging document properties
[#ex-merge-props]
// BEGIN inclusion -- block -- block_tabbed_code_example.adoc
//
//  Allows for abstraction of the showing of snippet examples
//  which makes displaying tabbed snippets for platforms with
//  more than one native language to show -- Android (Kotlin and Java)
//
// Surrounds code in Example block
//
//  PARAMETERS:
//    param-tags comma-separated list of tags to include/exclude
//    param-leader text for opening para of an example block
//
//  USE:
//    :param_tags: query-access-json
//    include::partial$block_show_snippet.adoc[]
//    :param_tags!:
//

[#android:conflict:::ex-merge-props]
====

// inject tab header
[tabs]
=====


Kotlin::
+
--

// Show Main Snippet
[source, Kotlin]
----
include ::android:example$codesnippet_collection.kt[tags="update-document-with-conflict-handler", indent=0]
val mutableDocument = collection.getDocument("xyz")?.toMutable() ?: return
mutableDocument.setString("name", "apples")
collection.save(mutableDocument) { newDoc, curDoc ->  // <.>
    if (curDoc == null) {
        return@save false
    } // <.>
    val dataMap: MutableMap<String, Any> = curDoc.toMap()
    dataMap.putAll(newDoc.toMap()) // <.>
    newDoc.setData(dataMap)
    true // <.>
} // <.>
----

--
// Show Optional Alternate Snippet

Java::
+
--
[source, Java]
----
include ::android:example$codesnippet_collection.java[tags="update-document-with-conflict-handler", indent=0]
Document doc = collection.getDocument("xyz");
if (doc == null) { return; }
MutableDocument mutableDocument = doc.toMutable();
mutableDocument.setString("name", "apples");

collection.save(
    mutableDocument,
    (newDoc, curDoc) -> {
        if (curDoc == null) { return false; }
        Map<String, Object> dataMap = curDoc.toMap();
        dataMap.putAll(newDoc.toMap());
        newDoc.setData(dataMap);
        return true;
    });
----
// Add tab closure
--

=====



// close example block

====

// Tidy-up atttibutes created
// END -- block_show_snippet.doc

//
//        <.> The conflict handler code is provided as a lambda.
//
//        <.> If the handler cannot resolve a conflict, it can return false.
//        In this case, the save method will cancel the save operation and return false the same way as using the save() method with the failOnConflict concurrency control.
//
//        <.> Within the conflict handler, you can modify the document parameter which is the same instance of Document that is passed to the save() method. So in effect, you will be directly modifying the document that is being saved.
//
//        <.> When handling is done, the method must return true (for  successful resolution) or false (if it was unable to resolve the conflict).
//
//        <.> If there is an exception thrown in the handle() method, the exception will be caught and re-thrown in the save() method



// end::handling-conflicts-custom-merge[]

// DO NOT EDIT OR REMOVE
// inclusion
//:param-how: //:param-reference: reference-deploy




[discrete#android:conflict:::related-content]
=== Related Content
++++
<div class="card-row three-column-row">
++++

[.column]
==== {empty}
.How to
* xref:android:p2psync-websocket-using-passive.adoc[Passive Peer]
* xref:android:p2psync-websocket-using-active.adoc[Active Peer]


.

[discrete.colum#android:conflict:::-2n]
==== {empty}
.Concepts
* xref:android:landing-p2psync.adoc[Peer-to-Peer Sync]

* https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-android}{empty}/couchbase-lite-android/[API References]

.


[.column]
// [.content]
[discrete#android:conflict:::-3]
==== {empty}
.Community Resources ...
//* Community
https://forums.couchbase.com/c/mobile/14[Mobile Forum] |
https://blog.couchbase.com/[Blog] |
https://docs.couchbase.com/tutorials/[Tutorials]


.
xref:tutorials:cbl-p2p-sync-websockets:swift/cbl-p2p-sync-websockets.adoc[Getting Started with Peer-to-Peer Synchronization]




++++
</div>
++++
// DO NOT EDIT OR REMOVE
// END -- inclusion -- common-conflict.adoc

// include::ROOT:partial$block-related-content-rep.adoc[]


== https://docs.couchbase.com/mobile/3.2.0/couchbase-lite-android/[API References]

== https://docs.couchbase.com/mobile/3.2.0/couchbase-lite-android-ktx[Kotlin Extensions]

