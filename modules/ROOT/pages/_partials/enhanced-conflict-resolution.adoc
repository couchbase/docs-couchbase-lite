Starting in Couchbase Lite 2.6, application developers who want more control over how document conflicts are handled can use custom logic to select the winner between conflicting revisions of a document.

A conflict can be resolved <<case-1-during-replication,during replication (case 1)>> or when <<case-2-when-saving-a-document,saving a document (case 2)>>.

If a custom conflict resolver is not provided, the system will automatically resolve conflicts as discussed in <<automatic-conflict-resolution,Automatic Conflict Resolution>>, and as a consequence there will be no conflicting revisions in the database.

CAUTION: While this is true of any user defined functions, app developers must be strongly cautioned against writing sub-optimal custom conflict handlers that are time consuming and could slow down the client's save operations.

==== Case 1: During Replication

To implement custom conflict resolution during replication, you must implement the following steps.

. <<conflict-resolver,Conflict Resolver>>
. <<configure-the-replicator,Configure the Replicator>>

===== Conflict Resolver

Apps have the following strategies for resolving conflicts:

- *Local Wins:* The current revision in the database wins.
- *Remote Wins:* The revision pulled from the remote endpoint through replication wins.
- *Merge:* Merge the content bodies of the conflicting revisions.

[{tabs}]
====
Local Wins::
+
--
[source]
----
include::{snippet}[tag=local-win-conflict-resolver,indent=0]
----
--

Remote Wins::
+
--
[source]
----
include::{snippet}[tag=remote-win-conflict-resolver,indent=0]
----
--

Merge::
+
--
[source]
----
include::{snippet}[tag=merge-conflict-resolver,indent=0]
----
--
====

When a null document is returned by the resolver, the conflict will be resolved as a document deletion.

===== Important Guidelines and Best Practices

There are some important points to be noted:

. If you have multiple replicators, it is recommended that instead of distinct resolvers, you should use a unified conflict resolver across all replicators.
Failure to do so could potentially lead to data loss under exception cases or if the app is terminated (by the user or an app crash) while there are pending conflicts.
. If the document ID of the document returned by the resolver does not correspond to the document that is in conflict then the replicator will log a warning message.
+
IMPORTANT: Developers are encouraged to review the warnings and fix the resolver to return a valid document ID.
. If a document from a different database is returned, the replicator will treat it as an error.
A <<replication-events,document replication event>> will be posted with an error and an error message will be logged.
+
IMPORTANT: Apps are encouraged to observe such errors and take appropriate measures to fix the resolver function.
. When the replicator is stopped, the system will attempt to resolve outstanding and pending conflicts before stopping.
Hence apps should expect to see some delay when attempting to stop the replicator depending on the number of outstanding documents in the replication queue and the complexity of the resolver function.
. If there is an exception thrown in the `resolve()` method, the exception will be caught and handled:
.. The conflict to resolve will be skipped.
// TODO: regarding the following point, does that mean the replicator is stopped when an exception is thrown?
The pending conflicted documents will be resolved when the replicator is restarted.
.. The exception will be reported in the warning logs.
.. The exception will be reported in the <<replication-events,document replication event>>.
+
IMPORTANT: While the system will handle exceptions in the manner specified above, it is strongly encouraged for the resolver function to catch exceptions and handle them in a way appropriate to their needs.

===== Configure the Replicator

The implemented custom conflict resolver can be registered on the replicator configuration object.
The default value of the conflictResolver is `null`.
When the value is `null`, the default conflict resolution will be applied.

[source]
----
include::{snippet}[tag=replication-conflict-resolver,indent=0]
----

==== Case 2: When Saving a Document

In Couchbase Lite versions 2.5 and earlier, by default, Couchbase Lite uses last-write-wins concurrency control to handle a conflict when saving a document.

Developers have the option to use <<automatic-conflict-resolution,fails-on-conflict>> (AKA optimistic concurrency control) so that they can manually handle the conflict when saving a document.

Starting in Couchbase Lite 2.6, we allow developers to hook a conflict handler when saving a document so that the developers can easily handle the conflict in a single save method call.

To implement custom conflict resolution when saving a document, you must implement the following steps.

. <<conflict-handler,Conflict Handler>>
. <<save-method-handler,Save Method Handler>>

===== Conflict Handler

Implemented by developers to provide a custom conflict handler.
Within the conflict handler, apps will be modifying the `document` parameter which is the same instance of `Document` that is passed to the `save()` method.
So in effect, apps will be directly modifying the document that is being saved.

When handling is done, the method must return `true`.
Returning `false` will cancel the save operation.

[source]
----
include::{snippet}[tag=example-conflict-handler,indent=0]
----

===== Save Method Handler

The `save()` method allows a conflict handler to be specified.

[source]
----
include::{snippet}[tag=update-document-with-conflict-handler,indent=0]
----

There are some important points to be noted:

. If the conflict handler returns `false`, the save method will cancel the save operation and return `false` the same way as using the `save()` method with the `failOnConflict` concurrency control.
. If there is an exception thrown in the `handle()` method, the exception will be caught and rethrown in the `save()` method.
