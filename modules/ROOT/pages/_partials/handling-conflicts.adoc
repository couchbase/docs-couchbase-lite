Document conflicts can occur when changes are made to the same version of a document by multiple peers in a distributed system.
With Couchbase Mobile, this can be a Couchbase Lite or Sync Gateway database instance, and conflicts can occur in the following scenarios:

* When a replication is in progress, or
* When saving a document

The following sections discuss each scenario in more detail.

=== Case 1: Conflicts when a replication is in progress

There's no practical way to prevent a conflict when two updates to a document are made on different instances of the app.
Neither app even knows that the other one has changed the document, until later on when replication propagates their incompatible changes to each other.
A typical scenario is:

. Molly creates DocumentA.
. DocumentA is synced to Naomi's device.
. Molly updates DocumentA, let's call it ChangeX for the purpose of this example.
. Naomi makes a different change to DocumentA, let's call it ChangeY.
. ChangeY is synced to Molly's device, which already has ChangeX, putting the document in conflict.
. ChangeX is synced to Naomi's device, which already has ChangeY, similarly putting the local document in conflict.

==== Automatic Conflict Resolution

Couchbase Lite uses the following rules to handle the conflicts occurring in steps 5 and 6.

* A deleted document (i.e tombstone) always wins over a document update.
* If both changes are document updates, the Last-Write-Win (LWW) algorithm is used to pick the winning update.

The result is saved internally by the Couchbase Lite replicator.
Those rules describe the internal behavior of the replicator.
There is currently no other way to handle conflicts when a replication is in progress.

==== Custom Conflict Resolution

Starting in Couchbase Lite 2.6, application developers who want more control over how document conflicts are handled can use custom logic to select the winner between conflicting revisions of a document.

If a custom conflict resolver is not provided, the system will automatically resolve conflicts as discussed in <<automatic-conflict-resolution,Automatic Conflict Resolution>>, and as a consequence there will be no conflicting revisions in the database.

CAUTION: While this is true of any user defined functions, app developers must be strongly cautioned against writing sub-optimal custom conflict handlers that are time consuming and could slow down the client's save operations.

To implement custom conflict resolution during replication, you must implement the following steps.

. <<conflict-resolver,Conflict Resolver>>
. <<configure-the-replicator,Configure the Replicator>>

===== Conflict Resolver

Apps have the following strategies for resolving conflicts:

- *Local Wins:* The current revision in the database wins.
- *Remote Wins:* The revision pulled from the remote endpoint through replication wins.
- *Merge:* Merge the content bodies of the conflicting revisions.

[{tabs}]
====
Local Wins::
+
--
[source]
----
include::{snippet}[tag=local-win-conflict-resolver,indent=0]
----
--

Remote Wins::
+
--
[source]
----
include::{snippet}[tag=remote-win-conflict-resolver,indent=0]
----
--

Merge::
+
--
[source]
----
include::{snippet}[tag=merge-conflict-resolver,indent=0]
----
--
====

When a null document is returned by the resolver, the conflict will be resolved as a document deletion.

===== Important Guidelines and Best Practices

There are some important points to be noted:

. If you have multiple replicators, it is recommended that instead of distinct resolvers, you should use a unified conflict resolver across all replicators.
Failure to do so could potentially lead to data loss under exception cases or if the app is terminated (by the user or an app crash) while there are pending conflicts.
. If the document ID of the document returned by the resolver does not correspond to the document that is in conflict then the replicator will log a warning message.
+
IMPORTANT: Developers are encouraged to review the warnings and fix the resolver to return a valid document ID.
. If a document from a different database is returned, the replicator will treat it as an error.
A <<replication-events,document replication event>> will be posted with an error and an error message will be logged.
+
IMPORTANT: Apps are encouraged to observe such errors and take appropriate measures to fix the resolver function.
. When the replicator is stopped, the system will attempt to resolve outstanding and pending conflicts before stopping.
Hence apps should expect to see some delay when attempting to stop the replicator depending on the number of outstanding documents in the replication queue and the complexity of the resolver function.
. If there is an exception thrown in the `resolve()` method, the exception will be caught and handled:
.. The conflict to resolve will be skipped.
// TODO: regarding the following point, does that mean the replicator is stopped when an exception is thrown?
The pending conflicted documents will be resolved when the replicator is restarted.
.. The exception will be reported in the warning logs.
.. The exception will be reported in the <<replication-events,document replication event>>.
+
IMPORTANT: While the system will handle exceptions in the manner specified above, it is strongly encouraged for the resolver function to catch exceptions and handle them in a way appropriate to their needs.

===== Configure the Replicator

The implemented custom conflict resolver can be registered on the replicator configuration object.
The default value of the conflictResolver is `null`.
When the value is `null`, the default conflict resolution will be applied.

[source]
----
include::{snippet}[tag=replication-conflict-resolver,indent=0]
----

=== Case 2: Conflicts when saving a document

When updating a document, you need to consider the possibility of update conflicts.
Update conflicts can occur when you try to update a document thatâ€™s been updated since you read it.
Here's a typical sequence of events that would create an update conflict:

. Your code reads the document's current properties, and constructs a modified copy to save.
. Another thread (perhaps the replicator) updates the document, creating a new revision with different properties.
. Your code updates the document (by calling `save(document: MutableDocument)`) with its modified properties.

==== Automatic Conflict Resolution

In Couchbase Lite 2.0, by default, the conflict is automatically resolved and only one document update is stored in the database.
The Last-Write-Win (LWW) algorithm is used to pick the winning update.
So in effect, the changes from step 2 would be overwritten and lost.

If the probability of update conflicts is high in your app and you wish to avoid the possibility of overwritten data, the `save` and `delete` APIs provide additional method signatures with concurrency control:

* `save(document: MutableDocument, concurrencyControl: ConcurrencyControl)`: attempts to save the document with a concurrency control.
The concurrency control parameter has two possible values:
** `lastWriteWins` (default): The last operation wins if there is a conflict.
** `failOnConflict`: The operation will fail if there is a conflict.
In this case, the app can detect the error that is being thrown, and handle it by re-reading the document, making the necessary conflict resolution, then trying again.

Similarly to the save operation, the delete operation also has two method signatures to specify how to handle a possible conflict:

* `delete(document: Document)`: The last write will win if there is a conflict.
* `delete(document: Document, concurrencyControl: ConcurrencyControl)`: attempts to delete the document with a concurrency control.
The concurrency control parameter has two possible values:
** `lastWriteWins` (default): The last operation wins if there is a conflict.
** `failOnConflict`: The operation will fail if there is a conflict.
In this case, the app can detect the error that is being thrown, and handle it by re-reading the document, making the necessary conflict resolution, then trying again.

==== Custom Conflict Resolution

Starting in Couchbase Lite 2.6, we allow developers to hook a conflict handler when saving a document so that developers can easily handle the conflict in a single save method call.

To implement custom conflict resolution when saving a document, apps must call the `save()` method with a conflict handler.

The following code snippet shows an example of merging properties from the existing document (`current`) into the one being saved (`new`).
In the event of conflicting keys, it will pick the key value from `new`.

[source]
----
include::{snippet}[tag=update-document-with-conflict-handler,indent=0]
----

Important points to be noted:

. Within the conflict handler, you can modify the `document` parameter which is the same instance of `Document` that is passed to the `save()` method.
So in effect, you will be directly modifying the document that is being saved.
. When handling is done, the method must return `true`.
. If the handler could not resolve the conflict, it can return `false`.
In this case, the save method will cancel the save operation and return `false` the same way as using the `save()` method with the `failOnConflict` concurrency control.
. If there is an exception thrown in the `handle()` method, the exception will be caught and rethrown in the `save()` method.
