// Inclusion
:param-related: {xref-cbl-pg-database} | {xref-cbl-pg-blob} | {xref-cbl-pg-indexing} |
:topic-group: Topic Group -- Data Model
include::{root-partials}block-abstract.adoc[]

:fn-rsvd-wds: footnote:fn1[Any change to this reserved key will be detected when it is saved and will result in a Couchbase exception (Error Code 5 -- `CorruptRevisionData`)]
:fnref-rsvd-wds: footnote:fn1[]

:to-dictionary: pass:a,q[`toDictionary()`]
:to-array: pass:a,q[`toArray()`]
:set-json: pass:a,q[`setJSON()`]
:to-json: pass:a,q[`toJSON()`]
ifdef::is-android,is-java[]
:to-dictionary: pass:a,q[`toMap()`]
endif::[]
ifdef::is-csharp[]
:to-dictionary: pass:a,q[`ToDictionary()`]
:to-json: pass:a,q[`ToJSON()`]
:set-json: pass:a,q[`SetJSON()`]
:to-array: pass:a,q[`ToArray()`]
endif::[]


== Overview

In Couchbase Lite, a document's body is stored in an internal, efficient, binary form.
This internal form is easily converted into a manageable native dictionary format for manipulation in applications by using the {to-dictionary} method.
It then appears as collection of key-value (k-v) pairs where the values can be different types of data such as numbers, strings, arrays or even nested objects.

Every document is identified by a document ID, which can be automatically generated (as a UUID) or specified programmatically;
the only constraints are that it must be unique within the database, and it can't be changed.

Couchbase Lite also provides for the direct handling of JSON data, whether as an object or a string. This applied to native types such as documents, blobs and arrays).
This approach is implemented in most cases by the provision of a {to-json} method on appropriate API classes (for example, on MutableDocument, Dictionary, Blob and Array) -- see <<lbl-json-data>>.
Used in conjunction with an appropriate serialization/de-serialization strategy this provides for a flexible data manipulation.


== Initializers

The following methods/initializers can be used:

* The {url-api-method-mutabledocument-init} initializer can be used to create a new document where the document ID is randomly generated by the database.
* The {url-api-method-mutabledocument-initid} initializer can be used to create a new document with a specific ID.
* The {url-api-method-database-getdocument} method can be used to get a document.
If it doesn't exist in the database, it will return `null`.
This method can be used to check if a document with a given ID already exists in the database.

The following code example creates a document and persists it to the database.

.Persist a document
====

[source, {source-language}]
----

include::{snippet}[tag=initializer,indent=0]

----
====

== Mutability

By default, when a document is read from the database it is immutable.
The {url-api-method-document-tomutable} method should be used to create an instance of the document which can be updated.

.Make a mutable document
====
Changes to the document are persisted to the database when the `save` method is called.

[source]
----
include::{snippet}[tag=update-document,indent=0]
----
====

NOTE: Any user change to the value of reserved keys (`_id`, `_rev` or `_deleted`) will be detected when a document is saved and will result in an exception (Error Code 5 -- `CorruptRevisionData`) -- see also <<document-constraints>>.


== Typed Accessors

=== Scalar type
The `Document` class now offers a set of {url-api-class-dictionary} for various scalar types, including boolean, integers, floating-point and strings.
These accessors take care of converting to/from JSON encoding, and make sure you get the type you're expecting.

=== Date accessors
// DateTimeOffset c#
In addition, as a convenience we offer `Date` accessors.
Dates are a common data type, but JSON doesn't natively support them, so the convention is to store them as strings in ISO-8601 format.
The following example sets the date on the `createdAt` property and reads it back using the {url-api-method-document-getdate} accessor method.

[source]
----
include::{snippet}[tag=date-getter,indent=0]
----
=== Checking for properties
To check whether a given property exists in the document, you should use the {url-api-method-document-contains} method.

If the property doesn't exist in the document it will return the default value for that getter method (0 for {url-api-method-document-getint} 0.0 for {url-api-method-document-getfloat} etc.).


ifeval::["{param-module}"=="swift"]

=== Document Conversion
A `Document` can be converted to a plain dictionary type and-or to a JSON string.
This can often be useful to pass the document contents as a plain object to another method.

.Convert document
====
[source]
----
include::{snippet}[tag=to-dictionary,indent=0]

include::{snippet}[tag=to-json,indent=0]

----

<.> Returns a Dictionary<String, Any>

<.> Returns a JSON string

====

endif::[]

[#lbl-json-data]
== Working with JSON Data
In this section::
<<lbl-array>>
| <<lbl-blob>>
| <<lbl-dictionary>>
| <<lbl-document>>
| <<lbl-result>>


The {to-json} typed-accessor means you can easily work with JSON data, native and Couchbase Lite objects.

[#lbl-array]
=== Arrays

Convert an `ArrayObject` to and from JSON using the {to-json} and `toArray` methods -- see: <<ex-array>>.

Additionally you can:

* Initialize a 'MutableArrayObject' using data supplied as a JSON string.
This is done using the `init(json)` constructor-- see: <<ex-array>>
* Convert an `ArrayFragment` object to a JSON String
* Set data with a JSON string using `setJSON()`

[#ex-array]
.Arrays as JSON strings
====
[source]
----
include::{snippet}[tag=toJson-array,indent=0]

----

<.> Initialize array with JSON string
<.> Create and save new document using the array
<.> Get native array object from new doc and print its elements
<.> Get an array from the document as a JSON string


+
[source, {source-language} ]
----

include::{snippet}[tag=toJson-array-output,indent=0]

----


====


[#lbl-blob]
=== Blobs

Convert a `Blob` to JSON using the `toJSON` method -- see <<ex-blob>>.

You can also check whether a given dictionary object is a blob, or not, using `isBlob()` -- again, see <<ex-blob>>.

Note that the blob object must first be saved to the database (generating required metadata) before you can use the `toJSON` method.

[#ex-blob]
.Blobs as JSON strings
====
[source]
----
include::{snippet}[tag=tojson-blob,indent=0]
----
====


[#lbl-dictionary]
=== Dictionaries

Convert a `DictionaryObject` to and from JSON using the `toJSON` and `toDictionary` methods -- see <<ex-dictionary>>.

Additionally you can:

* Initialize a 'MutableDictionaryObject' using data supplied as a JSON string.
This is done using the `init(json)` constructor-- see: <<ex-dictionary>>
* Set data with a JSON string using `setJSON()`

[#ex-dictionary]
.Dictionaries as JSON strings
====
[source]
----

include::{snippet}[tag=toJson-dictionary,indent=0]

----

<.> Set the dictionary using a JSON string

+
.Output

[source, {source-language} ]
----

include::{snippet}[tag=toJson-dictionary-output,indent=0]

----




====


[#lbl-document]
=== Documents

Convert a `Document` to and from JSON strings using the {to-json} and {set-json} methods -- see <<ex-document>>.

Additionally you can:

* Initialize a 'MutableDocument' using data supplied as a JSON string.
This is done using the `init(json)` and-or `init(id: json:)` constructor-- see: <<ex-document>>
* Set data with a JSON string using `setJSON()`


[#ex-document]
.Documents as JSON strings
====

[source, {source-language} ]
----

include::{snippet}[tags=query-get-all;toJson-document,indent=0]

----

<.> Get as document as a JSON string

<.> Initialize a MutableDocument using the JSON string and save to a seperate database

<.> Retrieve the document created from JSON and print values

+
[source, {source-language} ]
----

include::{snippet}[tag=toJson-document-output,indent=0]

----



====


[#lbl-result]
=== Query Results as JSON

Convert a `Query Result` to JSON using its {to-JSON} accessor method.

include::{root-commons}querybuilder-jsonresult.adoc[subs="macros,attributes"]


== Batch operations

If you're making multiple changes to a database at once, it's faster to group them together.
The following example persists a few documents in batch.

[source]
----
include::{snippet}[tag=batch,indent=0]
----

At the *local* level this operation is still transactional: no other `Database` instances, including ones managed by the replicator can make changes during the execution of the block, and other instances will not see partial changes.
But Couchbase Mobile is a distributed system, and due to the way replication works, there's no guarantee that Sync Gateway or other devices will receive your changes all at once.

== Document change events

It's also possible to register for document changes.
The following example registers for changes to the document with ID `user.john` and prints the `verified_account` property.

[source]
----
include::{snippet}[tag=document-listener,indent=0]
----

== Document Expiration

include::{root-partials}document-expiration.adoc[]

[#lbl-doc-constraints]
== Document Constraints

Couchbase Lite APIs do not explicitly disallow the use of attributes with the underscore prefix at the top level of document.
This is to facilitate the creation of documents for use either in _local only_ mode where documents are not synced, or when used exclusively in peer-to-peer sync.

NOTE: "_id", :"_rev" and "_sequence" are reserved keywords and must not be used as top-level attributes -- see <<res-keys>>.

Users are cautioned that any attempt to sync such documents to Sync Gateway will result in an error.
To be future proof, you are advised to avoid creating such documents.
Use of these attributes for user-level data may result in undefined system behavior.

For more guidance -- see: xref:sync-gateway:ROOT:data-modeling.adoc[Sync Gateway - data modeling guidelines]

[#res-keys]
.Reserved Keys List
====
* _attachments
* _deleted {fn-rsvd-wds}
* _id {fnref-rsvd-wds}
* _removed
* _rev {fnref-rsvd-wds}
* _sequence
====


include::{root-partials}block-related-content-data.adoc[]
