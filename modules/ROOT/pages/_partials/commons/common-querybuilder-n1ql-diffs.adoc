// = N1QL for Analytics vs. N1QL for Query
// :description: A comparison between N1QL for Analytics and N1QL for Query.
// :page-edition: Enterprise Edition
// BEGIN -- inclusion -- common-querybuilder.adoc
//  Purpose -- describes the use of the query syntax
//
// // BEGIN::REQUIRED EXTERNALS
// :this-module: {par-module}
// :this-lang-title: {par-lang-title}
// :this-packageNm: {par-packageNm}
// :this-source-language: {par-source-language}
// :snippet: {par-snippet}
//:this-url-issues: {par-url-issues}
// END::REQUIRED EXTERNALS


// == Introduction

There are several minor but notable behavior differences between N1QL queries on Couchbase Lite and N1QL on Couchbase Server, ashown in  <<tbl-diffs>>.

In some instance you can, if required, force Couchbase Lite to work in the same way as Couchbase Server. These instances are noted in the content below.

.N1QL Query Comparison (Couchbase Server _cf_ Couchbase Lite)
[#tbl-diffs, cols="^1,2a,2a, options="header"]
|===

|
2+^h|N1QL Comparison

h| Feature
h| Couchbase Server
h| Couchbase Lite

| USE KEYS
| SELECT fname, email FROM tutorial USE KEYS ["dave", "ian"];
| SELECT fname, email FROM tutorial WHERE meta().id IN ["dave", "ian"];

| ON KEYS
| SELECT * FROM user u +
JOIN orders o ON KEYS ARRAY s.order_id FOR s IN u.order_history END;
| SELECT * FROM user u, u.order_history s +
JOIN orders o ON s.order_id = meta(o).id;

| ON KEY
| SELECT * FROM user u +
JOIN orders o ON KEY o.user_id FOR u;
| SELECT * FROM user u +
JOIN orders o ON meta(u).id = o.user_id;

| NEST
| SELECT * FROM user u +
NEST orders orders +
ON KEYS ARRAY s.order_id FOR s IN u.order_history END;
| SELECT u, orders FROM users u +
LET orders=(SELECT VALUE o FROM u.order_history s, orders o WHERE meta(o).id = s.order_id) +
WHERE EXISTS orders;

| LEFT OUTER NEST
| SELECT * FROM user u +
LEFT OUTER NEST orders orders +
ON KEYS ARRAY s.order_id FOR s IN u.order_history END;
| SELECT u, (SELECT VALUE o FROM u.order_history s, orders o WHERE meta(o).id = s.order_id) orders +
FROM users u;

| ARRAY
| ARRAY i FOR i IN [1, 2] END
| (SELECT VALUE i FROM [1, 2] AS i)

| ARRAY FIRST
| ARRAY FIRST arr
| arr[0]

| LIMIT l OFFSET o
| Allows OFFSET without LIMIT
| Doesn't support OFFSET without LIMIT

| UNION, INTERSECT, and EXCEPT
| All three are supported (with ALL and DISTINCT variants)
| Only UNION ALL is supported (and necessary for query expressability)

| OUTER JOIN
| Both LEFT and RIGHT OUTER JOIN supported
| Only LEFT OUTER JOIN supported (and necessary for query expressability)

| <, \<=, =, etc. operators
| Can compare either complex values or scalar values
| Only scalar values may be compared

| ORDER BY
|Result sequencing is based on specific rules described in {svr-n1ql-reference-orderby--xref}
|Result sequencing is based on the SQLite ordering described in https://sqlite.org/lang_select.html[SQLite select overview]

The ordering of _Dictionary_ and _Array_ objects is based on binary ordering.


| SELECT DISTINCT
| Supported
| SELECT DISTINCT VALUE is supported when the returned values are scalars

| CREATE INDEX
| Supported
| Supported but different (e.g., typed)

| INSERT/UPSERT/DELETE
| Supported
| Unsupported (by design)
|===

// N1QL for Analytics generalizes N1QL for Query's syntax constructs such as `USE KEYS`, `ON KEYS`, `ON KEY`, `NEST`,
// `LEFT OUTER NEST` and `ARRAY` and thus eliminates cases where must-be-indexed or must-use-keys
// restrictions are required for certain N1QL for Query queries or expressions to be acceptable.
// In addition, the general composability of N1QL for Analytics queries eliminates the need for some of N1QL for Query's
// special syntax; for example, N1QL for Analytics does not require or support the IN/WITHIN subclauses of
// N1QL for Query's existential (SOME, ANY, or EVERY) expressions.

// Note that INSERT/UPSERT/DELETE are not supported at all in the Couchbase Analytics Service.
// Data is mutated in Couchbase Server, using the Couchbase Server SDK or N1QL for Query mutation, and
// the mutations will then be automatically synchronized into the Couchbase Analytics Service.
















== Boolean Logic Rules

Couchbase Lite N1QL's boolean logic rules are based on SQLite’s, so:

* TRUE is TRUE, and FALSE is FALSE
* Numbers 0 or 0.0 are FALSE
* Arrays and dictionaries are FALSE
* String and Blob are TRUE if the values are casted as a non-zero or FALSE if the values are casted as 0 or 0.0 (See SQLITE’s CAST and Boolean expressions here for more details)
* NULL is FALSE
* MISSING is MISSING

Couchbase Server operates in the same way as Couchbase Lite, except:

* MISSING, NULL and FALSE are FALSE
* Numbers 0 is FALSE
* Empty strings, arrays, and objects are FALSE
* All other values are TRUE

====
You can choose to use _Couchbase Server's N1QL rules_ by using the `TOBOOLEAN(expr)` function to convert a value to its boolean value.
====


=== Logical Operations

Couchbase Lite logical operations will return one of three possible values; `TRUE`, `FALSE`, or `MISSING`.

Logical operations with the `MISSING` value could result in `TRUE` or `FALSE` if the result can be determined regardless of the missing value, otherwise the result will be `MISSING`.

In Couchbase Lite N1QL -- unlike Couchbase Server N1QL -- `NULL` is implicitly converted to `FALSE` before evaluating logical operations.
<<tbl-logops>> summarizes the result of logical operations with different operand values and also shows where the Couchbase Server behavior differs.


.Logical Operations Comparison
[#tbl-logops, cols="^1m,^1m,^1m,^1m,^1m,^1m,^1m", options-"header"]
|===

.2+.>h| Operand +
a
3+h|Couchbase Lite
3+h|Couchbase Server

h| b
h| a AND b
h| a OR b
h| b
h| a AND b
h| a OR b

.4+| TRUE
| TRUE
| TRUE
| TRUE
// | TRUE
// | TRUE
// | TRUE
|-|-|-

| FALSE
| FALSE
| TRUE
|-|-|-
// | FALSE
// | FALSE
// | TRUE

| NULL
| FALSE
| TRUE
|-
// | NULL
| *NULL*
|-
// | TRUE

| MISSING
| MISSING
| TRUE
|-|-|-
// | MISSING
// | MISSING
// | TRUE

.4+| FALSE
| TRUE
| FALSE
| TRUE
|-|-|-
// | TRUE
// | FALSE
// | TRUE

| FALSE
| FALSE
| FALSE
|-|-|-
// | FALSE
// | FALSE
// | FALSE

| NULL
| FALSE
| FALSE
|-|-
// | NULL
// | FALSE
| *NULL*

| MISSING
| FALSE
| MISSING
|-|-|-
// | MISSING
// | FALSE
// | MISSING

.4+| NULL
| TRUE
| FALSE
| TRUE
// | TRUE
|-
| *NULL*
|-
// | TRUE

| FALSE
| FALSE
| FALSE
| -
| -
// | FALSE
// | FALSE
| *NULL*

| NULL
| FALSE
| FALSE
// | NULL
| -
| *NULL*
| *NULL*

| MISSING
| FALSE
| MISSING
| -
// | MISSING
| *MISSING*
| *NULL*

.4+|MISSING
| TRUE
| MISSING
| TRUE
|-|-|-
// | TRUE
// | MISSING
// | TRUE

| FALSE
| FALSE
| MISSING
|-|-|-
// | FALSE
// | FALSE
// | MISSING

| NULL
| FALSE
| MISSING
// | NULL
|-
| *MISSING*
| *NULL*

| MISSING
| MISSING
| MISSING
|-|-|-
// | MISSING
// | MISSING
// | MISSING


|===


=== Division Operator

In Couchbase Lite N1QL, the operands' type determines the
 division operation performed.
If both are integers, integer division is used.
If one is a floating number, then float division is used.

In contrast, Couchbase Server N1QL always performs float division regardless of the types of the operands.
====
You can force this behavior in Couchbase Lite N1QL by using the `DIV(x, y)` function.
====

=== Round Function

In Couchbase Lite N1QL, the `ROUND()` function returns a value to the given number of integer digits to the right of the decimal point (left if digits is negative).
Digits are 0 if not given.
Midpoint values are handled using the _Rounding Away From Zero_ convention, which rounds them to the next number away from zero (for example, `ROUND(1.85)` returns 1.9).

In Couchbase Server N1QL `ROUND()` uses the _Rounding to Nearest Even_ convention (for example, `ROUND(1.85)` returns 1.8).
====
You can force this behavior in Couchbase Lite by using the `ROUND_EVEN()` function.
====



// END --- inclusion -- common-querybuilder-n1ql.adoc