// = P2P Sync Using URLEndpointListener

// DO NOT EDIT
:topic-group: Using Peer-to-Peer Synchronization (web sockets)
include::ROOT:partial$block-related-howto-p2psync-ws.adoc[]
include::ROOT:partial$_show_page_header_block.adoc[]
// DO NOT EDIT

:zero-config: {empty}

ifdef::is-ios[]
:zero-config: such as Bonjour -- see: https://developer.apple.com/bonjour/
endif::[]
ifdef::is-android[]
:zero-config: such as Network Service Discovery -- see: https://developer.android.com/training/connect-devices-wirelessly/nsd
endif::[]

== Introduction
// tag::introduction-full[]
// tag::introduction[]
Couchbase Lite’s Peer-to-Peer synchronization solution offers secure storage and bidirectional data synchronisation between edge devices without needing a centralized cloud-based control point. 

// end::introduction[]

Couchbase Lite’s Peer-to-Peer data synchronization provides: 

* Instant WebSocket-based listener for use in Peer-to-Peer applications communicating over IP-based networks

* Simple application development, enabling sync with a short amount of code

* Optimized network bandwidth usage and reduced data transfer costs with Delta Sync support

* Securely sync data with built-in support for Transport Layer Security (TLS) encryption and authentication support

* Document management. Reducing conflicts in concurrent writes with built-in conflict management support

* Built-in network resiliency

// end::introduction-full[]

== Overview
Peer-to-Peer synchronization requires one Peer to act as the Listener to the other Peer’s replicator.

image::ROOT:docs-listener-diagram.png[,600]

Peer-to-Peer synchronization requires one Peer to act as the Listener to the other Peer’s replicator.
Therefore, to use Peer-to-Peer synchronization in your application, you must configure one Peer to act as a Listener using the Couchbase Listener API, the most important of which include _URLEndpointListener_ and _URLEndpointListenerConfiguration_.

.Simple workflow
====
. Configure the Listener (_passive peer_, or _server_)
. Initialize the Listener, which listens for incoming WebSocket connections (on a user-defined, or auto-selected, port)
. Configure a replicator (_active peer_, or _client_)
. Use some form of discovery phase, perhaps with a zero-config protocol {zero-config}, or use known URL endpoints, to identify a Listener
. Point the replicator at the Listener
. Initialize the replicator +
. Replicator and Listener engage in the configured security protocol exchanges to confirm connection
. If connection is confirmed then replication will commence, synchronizing the two data stores.

====

Here you can see configuration involves a {p2psync-websocket-using-passive--xref} and an {p2psync-websocket-using-active--xref} and a user-friendly Listener configuration in <<simple-configuration>>

You can also learn how to implement Peer-to-Peer synchronization by referring to our tutorial -- see: {tutorial--xref--p2psync}.

== Features

Couchbase Lite for {param-title}'s Peer-to-Peer synchronization solution provides support for cross-platform synchronization, for example, between Android and iOS devices.

Each listener instance serves one Couchbase Lite database. However, there is no hard limit on the number of Listener instances you can associate with a database.

Having a Listener on a database still allows you to open replications to the other clients. 
For example, a Listener can actively begin replicating to other Listeners while listening for connections. 
These replications can be for the same or a different database.

The Listener will automatically select a port to use or a user-specified port.
It will also listen on all available networks, unless you specify a specific network.

=== Security

Couchbases Lite's Peer-to-Peer synchronization supports encryption and authentication over TLS with multiple modes, including:

* No encryption, for example, clear text.
* CA Cert
* Self-signed Cert
* Anonymous Self-signed -- an auto-generated anonymous TLS identity is generated if no identity is specified.
This TLS identity provides encryption but *not* authentication. +
Any self-signed certificates generated by the convenience API are stored in {securestorage}.

The replicator (client) can handle certificates pinned by the Listener for authentication purposes.

Support is also provided for basic authentication using username and password credentials.
Whilst this can be used in clear text mode, developers are strongly advised to use TLS encryption.

For testing and development purposes, support is provided for the client (active, replicator) to skip verification of self-signed certificates; this mode should not be used in production.

=== Error Handling

When a Listener is stopped, then all connected replicators are notified by a WebSocket error. Your application should distinguish between transient and permanent connectivity errors.

==== Passive peers
A Passive Peer losing connectivity with an Active Peer will clean up any associated endpoint connections to that Peer. The Active Peer may attempt to reconnect to the Passive Peer.

==== Active peers
An Active Peer permanently losing connectivity with a Passive Peer will cease replicating.

An Active Peer temporarily losing connectivity with a passive Peer will use exponential backoff functionality to attempt reconnection.

=== Delta Sync

Optional delta-sync support is provided but is inactive by default.

Delta-sync can be enabled on a per-replication basis provided that the databases involved are also configured to permit it.
Statistics on delta-sync usage are available, including the total number of revisions sent as deltas.

=== Conflict Resolution

Conflict resolution for Peer-to-Peer synchronization works in the same way as it does for Sync Gateway replication, with both custom and automatic resolution available.

ifdef::is-ios[]

== Constraints
* Requires at least iOS 10 (dependency on keychains)

endif::is-ios[]

// :is-android:

[#simple-configuration]
== Basic Setup
You can configure a Peer-to-Peer synchronization with just a short amount of code as shown here in <<ex-simple-listener>> and <<ex-simple-replicator>>.

.Simple Listener
[#ex-simple-listener]
:param-tags: listener-simple
:param-leader: pass:q,a[This simple listener configuration will give you a listener ready to participate in an encrypted synchronization with a replicator providing a valid user name and password.]
include::ROOT:partial$block_tabbed_code_example.adoc[]
:param-tags!:
:param-leader!:
<.> Initialize the Listener configuration
<.> Configure the client authenticator to require basic authentication
<.> Initialize the Listener
<.> Start the Listener


.Simple Replicator
[#ex-simple-replicator]
:param-tags: replicator-simple
:param-leader: pass:q,a[This simple replicator configuration will give you an encrypted, bi-directional Peer-to-Peer synchronization with automatic conflict resolution.]
include::ROOT:partial$block_tabbed_code_example.adoc[]
:param-tags!:
:param-leader!:
<.> Get the Listener's endpoint.
Here we use a known URL, but it could be a URL established dynamically in a discovery phase.
<.> Initialize the replicator configuration with the database to be synchronized and the Listener it is to synchronize with
<.> Configure the replicator to expect a self-signed certificate from the Listener
<.> Configure the replicator to present basic authentication credentials if the Listener prompts for them (client authentication is optional)
<.> Initialize the replicator
<.> Start the replicator


// [tabs]
// ====

// Simple Listener::
// +
// --

// This simple configuration will give you a listener ready to participate in an encrypted synchronization with a replicator providing a valid user name and password.

// [source, {source-language}]
// ----

// include::{snippet}[tags=listener-simple, indent=0]

// ----

// <.> Initialize the listener configuration
// <.> Configure the client authenticator to require basic authentication
// <.> Initialize the listener
// <.> Start the listener

// --

// Simple Replicator::
// +
// --
// This simple replicator configuration will give you an encrypted, bi-directional Peer-to-Peer synchronization with automatic conflict resolution.

// [source, {source-language}]
// ----

// include::{snippet}[tags=replicator-simple, indent=0]

// ----

// <.> Get the listener's endpoint. Here we use a known URL, but it could be established dynamically in a discovery phase.
// <.> Initialize the replicator configuration with the database to be synchronized and the listener it is to synchronize with
// <.> Configure the replicator to expect a self-signed certificate from the listener
// <.> Configure the replicator to present basic authentication credentials if the listener prompts for them (client authentication is optional)
// <.> Initialize the replicator
// <.> Start the replicator

// --

// ====

// =====

== API Highlights

include::ROOT:partial$p2p-api.adoc[leveloffset=+1]

== Security

=== Authentication
// include::ROOT:partial$p2p-security.adoc[leveloffset=+1]

Peer-to-Peer sync supports <<using-basic-authentication, Basic Authentication>> and <<using-tls,TLS Authentication>>.
For anything other than test deployments, we strongly encourage the use of TLS. In fact, Peer-to-Peer sync using URLEndpointListener is encrypted using TLS by default.

The authentication mechanism is defined at the endpoint level, meaning that it is independent of the database being replicated.
For example, you may use basic authentication on one instance and TLS authentication on another when replicating multiple database instances.

NOTE: The Minimum supported version of TLS is TLS 1.2.

Peer-to-Peer synchronization using URLEndpointListener supports certificate based authentication of the server and-or Listener:

* Replicator certificates can be: self signed, from trusted CA or anonymous (system generated).
* Listeners certificates may be: self signed or trusted CA signed.
+
Where a TLS certificate is not explicitly specified for the Listener, the Listener implementation will generate anonymous certificate to use for encryption

* The URLEndpointListener supports the ability to opt out of TLS encryption communication.
+
Active clients replicating with a URLEndpointListener have the option to skip validation of server certificates when the Listener is configured with self-signed certificates.
+
This option is ignored when dealing with CA certificates.

[#using-secure-storage]
=== Using Secure Storage
TLS and its associated keys and certificates might require using secure storage to minimize the chances of a security breach.
The implementation of this storage differs from platform to platform.
<<secure-storage-details>> summarizes the secure storage used to store keys and certificates for {param-title}.

.Secure storage details
[#secure-storage-details,cols="1,4"]
|===

|Key |Value

// tag::android[]
|Platform
|Android

|Key Storage
|Android System KeyStore

|Certificate Storage
|Android System KeyStore

|Notes
a|* Android KeyStore was introduced from Android API 18.
* Android KeyStore security has evolved over time to provide more secure support. Please check this document for more info: https://source.android.com/security/keystore

|Reference
|https://developer.android.com/training/articles/keystore
// end::android[]

// tag::ios[]
|Platform
|MacOS/iOS

|Key Storage
|KeyChain

|Certificate Storage
|KeyChain

|Notes
a|Use kSecAttrLabel of the SecCertificate to store the TLSIdentity’s label

|Reference
|https://developer.apple.com/documentation/security/keychain_services
// end::ios[]

// tag::jvm[]
|Platform
|Java

|Key Storage
|User Specified KeyStore

|Certificate Storage
|User Specified KeyStore

|Notes
a|* The KeyStore represents a storage facility for cryptographic keys and certificates. It’s users’ choice to decide whether to persist the KeyStore or not.
* The supported KeyStore types are PKCS12 (Default from Java 9) and JKS (Default on Java 8 and below).

|Reference
|https://docs.oracle.com/javase/7/docs/api/java/security/KeyStore.html
// end::jvm[]

// tag::net[]
// tag::Net-exXamarin[]
|Platform
|.Net (excluding Xamarin)

|Key Storage
|Opaque; Keys are stored automatically by the runtime when storing the certificate with the PersistKeySet flag set.

|Certificate Storage
|User specified X509Store

|Notes
a|* Use a map file to map the stored certificates and TLSIdentity’s labels.
* The actual store of X509Store depends on platform implementation:
** Windows -- OS KeyStore
** macOS -- KeyChain
** Linux -- file on filesystem

|Reference
a|* Opaque Keys: https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.x509certificates.x509certificate2collection.import?view=netstandard-2.0#System_Security_Cryptography_X509Certificates_X509Certificate2Collection_Import_System_Byte___System_String_System_Security_Cryptography_X509Certificates_X509KeyStorageFlags_
* X509Store Reference: https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.x509certificates.x509store?view=netcore-3.1

// end::Net-exXamarin[]

|===

[cols="1,1"]
|===

// tag::Xamarin[]
|Platform
|Xamarin

|Key Storage
|RSACryptoServiceProvider provided by Xamarin.

|Certificate Storage
|User specified X509Store

|Notes
a|* Use a map file to map the stored certificates and TLSIdentity’s labels.
* The same label is used  to persist the key
* The current Xamarin’s RSACryptoServiceProvider implementation stores keys in files.
* Users can use TLSIdentity.getIdentity(X509Certificate2Collection) to create a TLSIdentity object if they would like to manage the keys and certificates themselves.


|Reference
a|* RSACryptoServiceProvider: https://docs.microsoft.com/en-us/dotnet/standard/security/how-to-store-asymmetric-keys-in-a-key-container
* X509Store Reference -- https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.x509certificates.x509store?view=netcore-3.1
// end::Xamarin[]
// end::net[]

|===

// == Sizing
// include::ROOT:partial$p2p-sizing.adoc[leveloffset=+1]

// DO NOT EDIT OR REMOVE
include::ROOT:partial$block-related-content-p2psync.adoc[]
