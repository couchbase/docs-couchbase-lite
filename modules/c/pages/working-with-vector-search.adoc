:docname: working-with-vector-search
:page-module: c
:page-relative-src-path: working-with-vector-search.adoc
:page-origin-url: https://github.com/couchbase/docs-couchbase-lite.git
:page-origin-start-path:
:page-origin-refname: antora-assembler-simplification
:page-origin-reftype: branch
:page-origin-refhash: (worktree)
[#c:working-with-vector-search:::]
=== Working with Vector Search
:page-status:
:page-edition: Enterprise
:page-aliases:
:page-role:
:description: Use Vector Search with Full Text Search and Query.
:keywords: edge AI api swift ios macos apple vector search generative

[abstract]
{description}

[#c:working-with-vector-search:::use-vector-search]
==== Use Vector Search

To configure a project to use vector search, follow the <<c:gs-install:::,installation instructions>> to add the Vector Search extension.

NOTE: You must install Couchbase Lite to use the Vector Search extension.

[#c:working-with-vector-search:::create-a-vector-index]
==== Create a Vector Index

This method shows how you can create a vector index using the Couchbase Lite Vector Search extension.

[source, c]
----

        // Create a vector index configuration with a document property named "vector",
        // 3 dimensions, and 100 centroids. Customize the encoding, the distance metric,
        // the number of probes, and the training size.
        // Note: Free the created encoding using CBLVectorEncoding_Free after creating the index.
        CBLVectorIndexConfiguration config{};
        config.expressionLanguage = kCBLN1QLLanguage;
        config.expression = FLStr("vector");
        config.dimensions = 3;
        config.centroids = 100;
        config.metric = kCBLDistanceMetricCosine;
        config.numProbes = 8;
        config.encoding = CBLVectorEncoding_CreateNone();
        config.minTrainingSize = 2500;
        config.maxTrainingSize = 5000;

----

First, initialize the `config` object with the `VectorIndexConfiguration()` method with the following parameters:

* The expression of the data as a vector.

* The width or `dimensions` of the vector index is set to `3`.

* The amount of `centroids` is set to `100`.
This means that there will be one hundred buckets with a single centroid each that gathers together similar vectors.

You can also alter some optional config settings such as `encoding`.
From there, you can create an index within a given collection, using the previously generated `config` object.

NOTE: The number of vectors, the width or dimensions of the vectors and the training size can incur high CPU and memory costs as the size of each variable increases.
This is because the training vectors have to be resident on the machine.

[#c:working-with-vector-search:::vector-index-configuration]
===== Vector Index Configuration

The table below displays the different configurations you can modify within your `VectorIndexConfiguration()` function.
For more information on specific configurations, see <<c:vector-search:::,Vector Search.>>

.Vector Index Configuration Options
[cols ="4*"]
|===
|Configuration Name |Is Required |Default Configuration |Further Information

|Expression
|image:couchbase-lite/current/{underscore}images/yes.png[]
|No default
| A SQL++ expression indicating where to get the vectors.
A document property for embedded vectors or
`prediction()` to call a registered Predictive model.
|Number of Dimensions
|image:couchbase-lite/current/{underscore}images/yes.png[]
|No default
|2-4096
|Number of Centroids
|image:couchbase-lite/current/{underscore}images/yes.png[]
|No default
|1-64000. The general guideline is an approximate square root of the number of documents
|Distance Metric
|image:couchbase-lite/current/{underscore}images/no.png[]
|Squared Euclidean Distance (euclideanSquared)
a|You can set the following alternates as your Distance Metric:

* cosine (1 - Cosine similarity)

* Euclidean

* dot (negated dot product)

|Encoding
|image:couchbase-lite/current/{underscore}images/no.png[]
| Scalar Quantizer(SQ) or SQ-8 bits
a|There are three possible configurations:

* None
No compression, No data loss
* Scalar Quantizer (SQ) or SQ-8 bits (Default)
Reduces the number of bits per dimension
* Product Quantizer (PQ)
Reduces the number of dimensions and bits per dimension

|Training Size
|image:couchbase-lite/current/{underscore}images/no.png[]
|The default values for both the minimum and maximum training size is zero.
The training size is calculated based on the number of Centroids and the encoding type.


a| The guidelines for the minimum and maximum training size are as follows:

* The minimum training size is set to 25x the number of Centroids or 2 ^PQ's^ ^bits^ when PQ is used

* The maximum training size is set to 256x the number of Centroids or 2 ^PQ's^ ^bits^ when PQ is used

|NumProbes
|image:couchbase-lite/current/{underscore}images/no.png[]
|The default value is 0. The number of Probes is calculated based on the number of Centroids
|A guideline for setting a custom number of probes is at least 8 or 0.5% the number of Centroids
|isLazy
|image:couchbase-lite/current/{underscore}images/no.png[]
|False
|Setting the value to true will enable lazy mode for the vector index

|===

CAUTION: Altering the default training sizes could be detrimental to the accuracy of returned results produced by the model and total computation time.

[#c:working-with-vector-search:::generating-vectors]
==== Generating Vectors

You can use the following methods to generate vectors in Couchbase Lite:

. You can call a Machine Learning(ML) model, and embed the generated vectors inside the documents.

. You can use the `prediction()` function to generate vectors to be indexed for each document at the indexing time.

. You can use Lazy Vector Index (lazy index) to generate vectors asynchronously from remote ML models that may not always be reachable or functioning, skipping or scheduling retries for those specific cases.

Below are example configurations of the previously mentioned methods.

[#c:working-with-vector-search:::create-a-vector-index-with-embeddings]
===== Create a Vector Index with Embeddings

This method shows you how to create a Vector Index with embeddings.

[source, c]
----

        CBLError err {};
        // Get the collection object named "colors" in the default scope.
        CBLCollection* collection =
            CBLDatabase_Collection(database, FLStr("colors"), FLStr("_default"), &err);
        if (collection == nullptr) { throw std::domain_error("No Collection Found"); }

        // Create a vector index configuration with a document property named "vector",
        // 3 dimensions, and 100 centroids.
        CBLVectorIndexConfiguration config {};
        config.expressionLanguage = kCBLN1QLLanguage;
        config.expression = FLStr("vector");
        config.dimensions = 3;
        config.centroids = 100;

        // Create a vector index from the configuration with the name "colors_index".
        bool result = CBLCollection_CreateVectorIndex(collection, FLStr("colors_index"), config, &err);
        if (!result) { throw std::domain_error("Create Index Error"); }

        CBLCollection_Release(collection);

----

. First, create the standard configuration, setting up an expression, number of dimensions and number of centroids for the vector embedding.

. Next, create a vector index, `colors_index`, on a collection and pass it the configuration.

[#c:working-with-vector-search:::create-vector-index-embeddings-from-a-predictive-model]
===== Create Vector Index Embeddings from a Predictive Model

This method generates vectors to be indexed for each document at the index time by using the `prediction()` function.
The key difference to note is that the `config` object uses the output of the `prediction()` function as the `expression` parameter to generate the vector index.

[source, c]
----

        // Register the predictive model named "ColorModel".
        CBL_RegisterPredictiveModel(FLStr("ColorModel"), model);

        CBLError err {};
        // Get the collection object named "colors" in the default scope.
        CBLCollection* collection =
            CBLDatabase_Collection(database, FLStr("colors"), FLStr("_default"), &err);
        if (collection == nullptr) { throw std::domain_error("No Collection Found"); }

        // Create a vector index configuration with an expression using the prediction
        // function to get the vectors from the registered predictive model.
        CBLVectorIndexConfiguration config {};
        config.expressionLanguage = kCBLN1QLLanguage;
        config.expression = FLStr("prediction(ColorModel, {\"colorInput\": color}).vector");
        config.dimensions = 3;
        config.centroids = 100;

        // Create a vector index from the configuration with the name "colors_index".
        bool result = CBLCollection_CreateVectorIndex(collection, FLStr("colors_index"), config, &err);
        if (!result) { throw std::domain_error("Create Index Error"); }

        CBLCollection_Release(collection);

----

NOTE: You can use less storage by using the `prediction()` function as the encoded vectors will only be stored in the index.
However, the index time will be longer as vector embedding generation is occurring at run time.

[#c:working-with-vector-search:::create-a-lazy-vector-index]
==== Create a Lazy Vector Index

Lazy indexing is an alternate approach to using the standard predictive model with regular vector indexes which handle the indexing process automatically.
You can use lazy indexing to use a ML model that is not available locally on the device and to create vector indexes without having vector embeddings in the documents.

[source, c]
----

        // Creating a lazy vector index using the document's 'color' key.
        // The value of this key will be used to compute a vector when updating the index.
        CBLVectorIndexConfiguration config{};
        config.expressionLanguage = kCBLN1QLLanguage;
        config.expression = FLStr("color");
        config.dimensions = 3;
        config.centroids = 100;
        config.isLazy = true;

----

You can enable lazy vector indexing by setting the `isLazy` property to `true` in your vector index configuration.

NOTE: Lazy Vector Indexing is opt-in functionality, the `isLazy` property is set to `false` by default.

[#c:working-with-vector-search:::updating-the-lazy-index]
===== Updating the Lazy Index

Below is an example of how you can update your lazy index.

[source, c]
----

        // Get the collection object
        CBLError err {};
        CBLCollection* collection =
            CBLDatabase_Collection(database, FLStr("colors"), FLStr("_default"), &err);
        if (collection == nullptr) { throw std::domain_error("No Collection Found"); }

        // Get the index object
        CBLQueryIndex* index = CBLCollection_GetIndex(collection, FLStr("colors_index"), &err);
        if (!index) { throw std::domain_error("Index Not Found"); }

        while (true) {
            // Start an update on it (in this case, limit to 50 entries at a time)
            CBLIndexUpdater* updater = CBLQueryIndex_BeginUpdate(index, 50, &err);
            if (!updater) {
                if (err.code != 0) { throw std::domain_error("Error Begin Update"); }
                // If updater is NULL and no error, that means there are no more entries to process
                break;
            }

            for (size_t i = 0; i < CBLIndexUpdater_Count(updater); i++) {
                // The value type will depend on the expression you have set in your index.
                // In this example, it is a string property.
                FLString value = FLValue_AsString(CBLIndexUpdater_Value(updater, i));
                std::string colorString = std::string((char*)value.buf, value.size);

                std::vector<float> vector;
                try {
                    // Call a MLModel to get a vector.
                    vector = Color::getVector(colorString);
                } catch (const TransientError& e) {
                    // Bad connection? Corrupted over the wire? Something bad happened
                    // and the vector cannot be generated at the moment. So skip
                    // this entry. The next time CBLQueryIndex_BeginUpdate is called,
                    // it will be considered again.
                    CBLIndexUpdater_SkipVector(updater, i);
                } catch (...) {
                    // An unexpected error happened.
                    CBLIndexUpdater_Release(updater);
                    throw std::domain_error("Error Getting a Vector");
                }

                bool success;
                if (!vector.empty()) {
                    // The size of the vector must match the number of dimensions set in the index.
                    // Otherwise, an error will be returned.
                    success = CBLIndexUpdater_SetVector(updater, i, vector.data(),vector.size(),  &err);
                } else {
                    // No vector applicable. Calling SetVector with NULL will
                    // cause the underlying document to NOT be indexed
                    success = CBLIndexUpdater_SetVector(updater, i, nullptr, 0, &err);
                }
                if (!success) {
                    CBLIndexUpdater_Release(updater);
                    throw std::domain_error("Error Setting a Vector");
                }
            }

            // This writes the vectors to the index. You MUST have either set or
            // skipped all the values inside the updater or this call will return an error.
            if (!CBLIndexUpdater_Finish(updater, &err)) {
                CBLIndexUpdater_Release(updater);
                throw std::domain_error("Error Finish Updating");
            }

            CBLIndexUpdater_Release(updater);
        }

        CBLQueryIndex_Release(index);

----

You procedurally update the vectors in the index by looping through the vectors in batches until you reach the value of the `limit` parameter.

The update process follows the following sequence:

. Get a value for the updater.

.. If the there is no value for the vector, handle it.
In this case, the vector will be skipped and considered the next time `BeginUpdate()` is called.
+
NOTE: A key benefit of lazy indexing is that the indexing process continues if a vector fails to generate.
For standard vector indexing, this will cause the affected documents to be dropped from the indexing process.
+
. Set the vector from the computed vector derived from the updater value and your ML model.

.. If there is no value for the vector, this will result in the underlying document to not be indexed.

. Once all vectors have completed the update loop, finish updating.

NOTE: `CBLIndexUpdater_Release()` will throw an error if any values inside the updater have not been set or skipped.

[#c:working-with-vector-search:::vector-search-sql-support]
==== Vector Search SQL++ Support

Couchbase Lite currently supports Hybrid Vector Search and the `APPROX_VECTOR_DISTANCE()` function.

IMPORTANT: Similar to the <<c:fts:::,Full Text Search>> `match()` function, the `APPROX_VECTOR_DISTANCE()` function and Hybrid Vector Search cannot use the `OR` expression with the other expressions in the related `WHERE` clause.

[#c:working-with-vector-search:::use-hybrid-vector-search]
==== Use Hybrid Vector Search

You can use Hybrid Vector Search (Hybrid Search) to perform vector search in conjunction with regular SQL++ queries.
With Hybrid Search, you perform vector search on documents that have already been filtered based on criteria specified in the `WHERE` clause.

NOTE: A `LIMIT` clause is required for non-hybrid Vector Search, this avoids a slow, exhaustive unlimited search of all possible vectors.

[#c:working-with-vector-search:::hybrid-vector-search-with-full-text-match]
===== Hybrid Vector Search with Full Text Match

Below is an example of using Hybrid Search with the Full Text `match()` function.

[source, c]
----

        // Create a hybrid vector search query by using ORDER BY and WHERE clause.
        CBLError err{};
        const char* sql = "SELECT meta().id, color "
                          "FROM _default.colors "
                          "WHERE MATCH(color_desc_index, $text) "
                          "ORDER BY approx_vector_distance(vector, $vector) "
                          "LIMIT 8";

        CBLQuery* query = CBLDatabase_CreateQuery(database, kCBLN1QLLanguage,
                                                  FLStr(sql),
                                                  nullptr, &err);

        // Use ML model to get a vector (an array of floats) for the input color.
        std::vector colorVector = Color::getVector("FF00AA");

        // Set the vector array to the parameter "$vector"
        auto colorArray = FLMutableArray_New();
        for (auto val : colorVector) {
            FLMutableArray_AppendFloat(colorArray, val);
        }

        // Set the vector array to the parameter "$vector".
        auto params = FLMutableDict_New();
        // Set the vector array to the parameter "$vector".
        FLMutableDict_SetArray(params, FLStr("vector"), colorArray);
        // Set the vector array to the parameter "$text".
        FLMutableDict_SetString(params, FLStr("$text"), FLStr("vibrant"));
        CBLQuery_SetParameters(query, params);

        FLMutableArray_Release(colorArray);
        FLMutableDict_Release(params);

        // Execute the query:
        auto results = CBLQuery_Execute(query, &err);
        if (!results) {
            throw std::domain_error("Invalid Query");
        }

        while(CBLResultSet_Next(results)) {
            // Process result
        }

----

[#c:working-with-vector-search:::prediction-with-hybrid-vector-search]
===== Prediction with Hybrid Vector Search

Below is an example of using Hybrid Search with an array of vectors generated by the `Prediction()` function at index time.

[source, c]
----

        // Create a hybrid vector search query by using ORDER BY and WHERE clause.
        CBLError err{};
        const char* sql =
        "SELECT meta().id, color "
        "FROM _default.colors "
        "WHERE saturation > 0.5 "
        "ORDER BY approx_vector_distance(prediction(ColorModel, {\"colorInput\": color}).vector, $vector) "
        "LIMIT 8";

        CBLQuery* query = CBLDatabase_CreateQuery(database, kCBLN1QLLanguage,
                                                  FLStr(sql),
                                                  nullptr, &err);

        // Use ML model to get a vector (an array of floats) for the input color.
        std::vector colorVector = Color::getVector("FF00AA");

        // Set the vector array to the parameter "$vector"
        auto colorArray = FLMutableArray_New();
        for (auto val : colorVector) {
            FLMutableArray_AppendFloat(colorArray, val);
        }

        // Set the vector array to the parameter "$vector".
        auto params = FLMutableDict_New();
        FLMutableDict_SetArray(params, FLSTR("vector"), colorArray);
        CBLQuery_SetParameters(query, params);

        FLMutableArray_Release(colorArray);
        FLMutableDict_Release(params);

        // Execute the query:
        auto results = CBLQuery_Execute(query, &err);
        if (!results) {
            throw std::domain_error("Invalid Query");
        }

        while(CBLResultSet_Next(results)) {
            // Process result
        }

----

[#c:working-with-vector-search:::approx_vector_distancevector-expr-target-vector-metric-nprobes-accurate]
==== `APPROX_VECTOR_DISTANCE(vector-expr, target-vector, [metric], [nprobes], [accurate])`

WARNING: If you use a different distance metric in the `APPROX_VECTOR_DISTANCE()` function from the one configured in the index, you will receive an error when compiling the query.

[cols = "3*"]
|===
|Parameter |Is Required |Description

|vector-expr
|image:couchbase-lite/current/{underscore}images/yes.png[]
|The expression returning a vector (NOT Index Name).
Must match the expression specified in the vector index exactly.
|target-vector
|image:couchbase-lite/current/{underscore}images/yes.png[]
|The target vector.
|metric
|image:couchbase-lite/current/{underscore}images/no.png[]
|Values : "EUCLIDEAN_SQUARED", “L2_SQUARED”, “EUCLIDEAN”, “L2”,  ”COSINE”, “DOT”.
If not specified, the metric set in the vector index is used.
If specified, the metric must match with the metric set in the vector index.
This optional parameter allows multiple indexes to be attached to the same field in a document.
|nprobes
|image:couchbase-lite/current/{underscore}images/no.png[]
|Number of buckets to search for the nearby vectors.
If not specified, the nprobes set in the vector index is used.
|accurate
|image:couchbase-lite/current/{underscore}images/no.png[]
|If not present, false will be used, which means that the quantized/encoded vectors in the index will be used for calculating the distance.

IMPORTANT: Only accurate = false is supported

|===

[#c:working-with-vector-search:::use-approx_vector_distance]
===== Use `APPROX_VECTOR_DISTANCE()`

[source, c]
----

        // Create a query by using the approx_vector_distance() in the WHERE clause.
        CBLError err{};
        const char* sql = "SELECT id, color "
                          "FROM _default.colors "
                          "WHERE approx_vector_distance(vector, $vector) < 0.5 "
                          "LIMIT 8";

        CBLQuery* query = CBLDatabase_CreateQuery(database, kCBLN1QLLanguage,
                                                  FLStr(sql),
                                                  nullptr, &err);

        // Use ML model to get a vector (an array of floats) for the input color.
        std::vector colorVector = Color::getVector("FF00AA");

        // Set the vector array to the parameter "$vector"
        auto colorArray = FLMutableArray_New();
        for (auto val : colorVector) {
            FLMutableArray_AppendFloat(colorArray, val);
        }

        // Set the vector array to the parameter "$vector".
        auto params = FLMutableDict_New();
        FLMutableDict_SetArray(params, FLSTR("vector"), colorArray);
        CBLQuery_SetParameters(query, params);

        FLMutableArray_Release(colorArray);
        FLMutableDict_Release(params);

        // Execute the query:
        auto results = CBLQuery_Execute(query, &err);
        if (!results) {
            throw std::domain_error("Invalid Query");
        }

        while(CBLResultSet_Next(results)) {
            // Process result
        }

----

This function returns the approximate distance between a given vector, typically generated from your ML model, and an array of vectors with size equal to the `LIMIT` parameter, collected by a SQL++ query using `APPROX_VECTOR_DISTANCE()`.

[#c:working-with-vector-search:::prediction-with-approx_vector_distance]
===== Prediction with `APPROX_VECTOR_DISTANCE()`

Below is an example of using `APPROX_VECTOR_DISTANCE()` with an array of vectors generated by the `Prediction()` function at index time.

[source, c]
----

        // Create a vector search query that uses prediction() for computing vectors.
        CBLError err{};
        const char* sql = "SELECT id, color "
                          "FROM _default.colors "
                          "ORDER BY approx_vector_distance(prediction(ColorModel, {\"colorInput\": color}).vector, $vector) "
                          "LIMIT 8";

        CBLQuery* query = CBLDatabase_CreateQuery(database, kCBLN1QLLanguage,
                                                  FLStr(sql),
                                                  nullptr, &err);

        // Use ML model to get a vector (an array of floats) for the input color.
        std::vector colorVector = Color::getVector("FF00AA");

        // Set the vector array to the parameter "$vector"
        auto colorArray = FLMutableArray_New();
        for (auto val : colorVector) {
            FLMutableArray_AppendFloat(colorArray, val);
        }

        // Set the vector array to the parameter "$vector".
        auto params = FLMutableDict_New();
        FLMutableDict_SetArray(params, FLSTR("vector"), colorArray);
        CBLQuery_SetParameters(query, params);

        FLMutableArray_Release(colorArray);
        FLMutableDict_Release(params);

        // Execute the query:
        auto results = CBLQuery_Execute(query, &err);
        if (!results) {
            throw std::domain_error("Invalid Query");
        }

        while(CBLResultSet_Next(results)) {
            // Process result
        }

----

[#c:working-with-vector-search:::see-also]
==== See Also

* <<c:gs-install:::,Installation Instructions>>

* <<c:vector-search:::>>

* <<c:fts:::,Full Text Search>>


