:docname: field-level-encryption
:page-module: c
:page-relative-src-path: field-level-encryption.adoc
:page-origin-url: https://github.com/couchbase/docs-couchbase-lite.git
:page-origin-start-path:
:page-origin-refname: antora-assembler-simplification
:page-origin-reftype: branch
:page-origin-refhash: (worktree)
[#c:field-level-encryption:::]
= Field Level Encryption
:page-status: pass:q,a[Enterprise]
:page-role:
:description: Client-side Field Level Encryption on Couchbase Lite C Clients











































































// :param-name: c
// :param-title: C
// :param-module: c


IMPORTANT: This is an https://www.couchbase.com/products/editions[Enterprise Edition] feature.


.Community Edition
[CAUTION]
--
* The push replicator will detect encryptable values inside a document. It will fail to replicate unencrypted encryptable values with a crypto error.
* The pull replicator will *not* detect encryptable values inside pulled documents.
The document will be saved as it was received.
This *may* include Server SDK encrypted fields
--


[discrete#c:field-level-encryption:::overview]
== Overview


Couchbase Lite for C 3.0.0  supports client-side, field-Level encryption on replications, allowing applications to encrypt/decrypt sensitive fields in documents using an encryption framework of choice.

Using the new client-side encryption capability, Couchbase Lite C applications can
designate selected fields for encryption and have the client automatically handle the encryption and-or decryption at property level during the replication.

Only clients with access to the correct encryption keys can decrypt and read the protected data.

The client-side encryption is compatible with the Couchbase server SDK field-level encryption format -- see, for example,
https://docs.couchbase.com/python-sdk/current/concept-docs/encryption.html#format


[discrete#c:field-level-encryption:::encryptable-type]
== Encryptable Type


The API includes a `CBLEncryptable` type, representing an encryptable value to be automatically encrypted/decrypted the replicator -- see <<c:field-level-encryption:::ex-encryptable-type>>.

You declare  properties requiring encryption by the replicator, as a dictionary with the structure shown in <<c:field-level-encryption:::ex-encryptable-type>>.

[#c:field-level-encryption:::ex-encryptable-type]
.Encryptable-type Dictionary Structure
====
[source, c]
----
{
  "@type": "encryptable",
  “value” : <Decrypted Value>
} // <.>

{
  "@type": "encryptable",
  “ciphertext”: <Encrypted Value in BASE64 String>
} // <.>

----
The key for the value can be either of the following:

<.> Use `value` as the key when storing a decrypted value, which can be any type (string, number, boolean, dictionary, array or null).

<.> Use `cyphertext` as the key when storing a encrypted value, which must be a BASE-64 String.
====


[discrete#c:field-level-encryption:::replicator-decryption]
== Replicator Decryption


Pull replication detects `encryptable` values before saving them to the local database and decrypts them using the property decryption callback function -- see: <<c:field-level-encryption:::lbl-decryption-callback>> for more on the decryption callback function.

On successful decryption the replicator saves the property in encryptable dictionary format (removing the `encrypted$` prefix) -- see: <<c:field-level-encryption:::ex-encryptable-type>>.


[discrete#c:field-level-encryption:::replicator-encryption]
== Replicator Encryption


Push replication detects `encryptable` values before pushing them to the remote database and encrypts them using the property encryption callback function -- see: <<c:field-level-encryption:::lbl-encryption-callback>>.

On successful encryption the replicator transforms the property into a format compatible with Couchbase Server SDK -- see: <<c:field-level-encryption:::ex-server-encryptable>>.


[discrete#c:field-level-encryption:::server-sdk-compatibility]
== Server SDK compatibility


Couchbase Lite's replicator ensures compatibility with Server SDK’s field level.
Both Push and Pull replication transform Couchbase Lite's encryptable dictionary to-and-from Server SDK Encrypted Field dictionary structure -- see: <<c:field-level-encryption:::ex-server-encryptable>>.

Push replicator::
* Adds the prefix `encrypted$` to the key.
* Sets the SDK'` `alg` either to a user-specified algorithm name or the default `CB_MOBILE_CUSTOM`.
* Set the value's key as `ciphertext`
* Stores the encrypted value as a BASE64 string.
+
.Stored Encryptable
====
[source]
----
{
    “alg”: <User-Specified or CB_MOBILE_CUSTOM>,
    “ciphertext” : <Encrypted Value in BASE64 String>
}
----
====

Pull replicator::

* Detects encrypted encryptable values by looking for  dictionary keys prefixed with “encrypted$”.
* Transforms the dictionary by:
** Removing `alg`
** Replacing the `ciphertext` key with the `value`
** Storing the decrypted key/value in <<c:field-level-encryption:::ex-encryptable-type,CBLEncryptable>> format


.Server SDK Encrypted Field Structure
[#c:field-level-encryption:::ex-server-encryptable]
====
Server SDK's field (property) level encryption uses key mangling, by add a prefix to the field name (`encrypted$`).
Its directory structure differs CBL's encryptable dictionary when serializing the encrypted fields; as shown here.

[source]
----
{
    encrypted$mykey: {
        “alg” : “AEAD_AES_256_CBC_HMAC_SHA512”, // <.>
        “kid” : “my-key-id”,
        “ciphertext”: “<BASE64-TEXT>”
    }
}
----
<.> Here `alg` identifies the encryption algorithm and is the only required field.

====

[discrete#c:field-level-encryption:::callback-definition]
== Callback Definition


[discrete#c:field-level-encryption:::lbl-encryption-callback]
=== Encryption

Provide an encryption callback function https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-c}{empty}/couchbase-lite-c/C/html/group__replication.html#gab116a23be8bd24b86349379f370ef60c[CBLPropertyEncryptor] to encrypt encryptable properties during replication.

After encryption the FLSliceResult is released and the returned value zeroed.
See <<c:field-level-encryption:::ex-get-att>> for an example encryptor callback function.

If you return a null slice the replicator will fail and log a crypto error message.

[discrete#c:field-level-encryption:::lbl-decryption-callback]
=== Decryption

Provide a decryption callback function https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-c}{empty}/couchbase-lite-c/C/html/group__replication.html#ga24a60a3d6f9816e1d32464cc31a15c0c[CBLPropertyDecryptor] to decrypt any encryptable properties.
After decryption the FLSliceResult is released and the returned value zeroed.
See <<c:field-level-encryption:::ex-get-att>> for an example decryptor callback function.

If you return a null slice without an error the replicator skips and saves the property as received.

If you return a null slice with an error the replicator logs the error and does not replicate the document.


.Simple Encryption-Decryption Callback
[#c:field-level-encryption:::ex-get-att]
====
// :param-tags: replicator_property_encryptor_decryptor_sample
// include::ROOT:partial$block_tabbed_code_example.adoc[]
// :param-tags!:
[source, C]
----
// Purpose: Declare property-level encryptor callback functions
static FLSliceResult my_cipher_function(FLSlice input) {
    FLSliceResult result = FLSliceResult_New(input.size);
    for(int i = 0; i < input.size; ++i) {
        ((uint8_t*)(result.buf))[i] = ((uint8_t*)input.buf)[i] ^ 'K';}
    return result;
}


static FLSliceResult property_encryptor(void* context, FLString docID, FLDict props, FLString path,
                                        FLSlice input, FLStringResult* algorithm, FLStringResult* keyID, CBLError* error) {
    *algorithm = FLSlice_Copy(FLSTR("MyEnc"));
    return my_cipher_function(input);
}


static FLSliceResult property_decryptor(void* context, FLString documentID, FLDict properties, FLString keyPath,
                                        FLSlice input, FLString algorithm, FLString keyID, CBLError* error) {
    return my_cipher_function(input);
}

----
====

[discrete#c:field-level-encryption:::callback-configuration]
== Callback Configuration

You register the callback function for use by declaring them in the replicator configuration using https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-c}{empty}/couchbase-lite-c/C/html/struct_c_b_l_replicator_configuration.html#ab731bf9f140158d6967c1af645d8744a[propertyEncryptor()] and-or https://docs.couchbase.com/mobile/{major}.{minor}.{maintenance-c}{empty}/couchbase-lite-c/C/html/struct_c_b_l_replicator_configuration.html#ab6a0d9e0830755d284039018a09c27d6[propertyDecryptor()] -- see: <<c:field-level-encryption:::ex-callback-config>>

If you do not provide an encryption callback:

* The push replicator always detects encrypted encryptable values in a document and will fail the document replication, flagging a crypto error.

* The pull replicator does *not* detect encrypted encryptables in pulled documents and will save documents as received; this could include SDK encrypted field dictionaries.


.Simple Callback Replicator Configuration
[#c:field-level-encryption:::ex-callback-config]
====
[source, C, subs="attributes+, macros+"}]
----
// Purpose: Declare property-level encryptor callback functions
static FLSliceResult my_cipher_function(FLSlice input) {
    FLSliceResult result = FLSliceResult_New(input.size);
    for(int i = 0; i < input.size; ++i) {
        ((uint8_t*)(result.buf))[i] = ((uint8_t*)input.buf)[i] ^ 'K';}
    return result;
}


static FLSliceResult property_encryptor(void* context, FLString docID, FLDict props, FLString path,
                                        FLSlice input, FLStringResult* algorithm, FLStringResult* keyID, CBLError* error) {
    *algorithm = FLSlice_Copy(FLSTR("MyEnc"));
    return my_cipher_function(input);
}


static FLSliceResult property_decryptor(void* context, FLString documentID, FLDict properties, FLString keyPath,
                                        FLSlice input, FLString algorithm, FLString keyID, CBLError* error) {
    return my_cipher_function(input);
}

    // Purpose: Show how to declare en(de)cryptors in replicator config
    // NOTE: No error handling, for brevity (see getting started)

    CBLError err;
    FLString url = FLSTR("ws://localhost:4984/db");
    CBLEndpoint* target = CBLEndpoint_CreateWithURL(url, &err);

    CBLReplicationCollection collectionConfig;
    memset(&collectionConfig, 0, sizeof(CBLReplicationCollection));
    collectionConfig.collection = collection;

    CBLReplicatorConfiguration replConfig;
    memset(&replConfig, 0, sizeof(CBLReplicatorConfiguration));
    replConfig.collectionCount = 1;
    replConfig.collections = &collectionConfig;
    replConfig.endpoint = target;
    replConfig.propertyEncryptor = property_encryptor; // <.>
    replConfig.propertyDecryptor = property_decryptor; // <.>

    CBLReplicator* replicator = CBLReplicator_Create(&replConfig, &err);
    CBLEndpoint_Free(target);

    CBLReplicator_Start(replicator, false);
----
====
// :param-tags: replicator_property_encryption
// include::ROOT:partial$block_tabbed_code_example.adoc[]
// :param-tags!:


[discrete#c:field-level-encryption:::querying-encryptables]
== Querying Encryptables


Encrypted values can be queried -- see <<c:field-level-encryption:::ex-query>>.
The query result of an encryptable value is `CBLEncryptable`

CBLEncryptable exposes a _value_ property for query purposes.
If this value is encrypted the query will return _MISSING_.

[#c:field-level-encryption:::ex-query]
.A Simple encryptable Query
====
[source, nql]
----
SELECT  ssn,  // <.>
        ssn.value  // <.>
FROM db WHERE ssn.value = "123-45-6789"
----

<.> The returned `ssn` column is in the form of an encryptable dictionary
<.> The returned `ssn.value` column is the actual value, unless it is still encrypted in which case it returns MISSING
====


[discrete#c:field-level-encryption:::constraints]
== Constraints


[discrete#c:field-level-encryption:::nesting]
=== Nesting
In the case of nested `encryptable` types, the replicator only encrypts the outer `encryptable`.

[discrete#c:field-level-encryption:::arrays]
=== Arrays
For compatibility with Server SDKS, encryptables are not supported within arrays.

The push replicator should detect and report an error if an encrypted property is found in an array.

[discrete#c:field-level-encryption:::blobs]
=== Blobs
Encrypting blob’s content is not supported.

Where a Blob as a Fleece dictionary is specified in the encrypted property value, only the dictionary is encrypted; *not* the blob’s content.

[discrete#c:field-level-encryption:::delta-sync]
=== Delta Sync
Delta Sync will be disabled and a warning message logged when `propertyEncryption` is configured.


[discrete#c:field-level-encryption:::brute-force-susceptibility]
=== Brute-Force Susceptibility

Any document with simple encrypted fields (for example, fields containing a subset of values) may be brute-force computed with all possible values using the document revId.
This will be fixed in a future release.
In the meantime, adding an encrypted field including a nonce or random value to the document can mitigate against such brute-force computation -- as shown in <<c:field-level-encryption:::example-brute-force-mitigation>>.


[#c:field-level-encryption:::example-brute-force-mitigation]
.Sample brute-force mitigation code
====
[source, C]
----
void secureRandomize(void *bytes, size_t count) {
    // This sample code uses Apple’s Common Crypto API to generate a secure random bytes.
    CCRandomGenerateBytes(bytes, count);
}
----


[source, C]
----
…

auto doc = CBLDocument_CreateWithID("doc1"_sl);
FLMutableDict props = CBLDocument_MutableProperties(doc);

// Create a random bytes in base64:
uint8_t nonceBuf[64];
secureRandomize(nonceBuf, sizeof(nonceBuf));
FLValue nonceValue = FLValue_NewData({nonceBuf, sizeof(nonceBuf)});
FLSliceResult nonceBase64 = FLValue_ToJSON(nonceValue);
FLValue_Release(nonceValue);

// Create an encryptable value from the random bytes and add to the document’s property:
auto nonce = CBLEncryptable_CreateWithString({nonceBase64.buf, nonceBase64.size});
FLMutableDict_SetEncryptableValue(props, "nonce"_sl, nonce);

…

// Save doc:
CBLError error;
CHECK(CBLDatabase_SaveDocument(db, doc, &error));

// Release:
CBLDocument_Release(doc);
FLSliceResult_Release(nonceBase64);
CBLEncryptable_Release(nonce);

----

====



[discrete#c:field-level-encryption:::related-content]
== Related Content
++++
<div class="card-row three-column-row">
++++

[.column]
=== {empty}
.How to . . .
* xref:c:gs-prereqs.adoc[Prerequisites]
* xref:c:gs-install.adoc[Install]
* xref:c:gs-build.adoc[Build and Run]


.

[discrete.colum#c:field-level-encryption:::-2n]
=== {empty}
.Learn more . . .
* xref:c:database.adoc[Databases]
* xref:c:document.adoc[Documents]
* xref:c:blob.adoc[Blobs]
* xref:c:replication.adoc[Remote Sync Gateway]
* xref:c:conflict.adoc[Handling Data Conflicts]

.


[discrete.colum#c:field-level-encryption:::-3n]
=== {empty}
.Dive Deeper . . .
https://forums.couchbase.com/c/mobile/14[Mobile Forum] |
https://blog.couchbase.com/[Blog] |
https://docs.couchbase.com/tutorials/[Tutorials]

.



++++
</div>
++++


= Queries

