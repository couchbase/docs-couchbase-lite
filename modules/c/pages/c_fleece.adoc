= Fleece C API
:page-edition: {release}
:page-status: pass:q,a[{prerelease}]
:page-role:
:description: Introducing the key concepts of the Fleece C API

include::partial$_std-cbl-hdr-c.adoc[]

:url_fleece_on_github: https://github.com/couchbaselabs/fleece[Fleece on GitHub]
:url_using_fleece: https://github.com/couchbaselabs/fleece/wiki/Using-Fleece[Using Fleece]
:url_fleece_hdr: https://github.com/couchbaselabs/fleece/blob/master/API/fleece/Fleece.h[Fleece Header File]

:url_flslice_hdr: https://github.com/couchbaselabs/fleece/blob/master/API/fleece/FLSlice.h[FLSlice.h]


== Introduction

{cbl-te} for C makes extensive use of the Fleece C API for accessing document data.
This content introduces some basic Fleece API concepts and examples.

Fleece is a binary encoding for semi-structured data.
Its data model is a superset of JSON, adding support for binary data (blobs) to give seven data types: null, boolean, numbers, strings, data, arrays, and dictionaries.
Arrays can contain any data types.
Dictionary keys are strings, with values of any data type.

Fleece is designed to be:

* Very fast to read: +
No parsing is needed, and the data can be navigated and read without any heap allocation.
Fleece objects are internal pointers into the raw data.
Arrays and dictionaries can be random-accessed.
Performance on real-world-scale data has been clocked at 20x that of JSON.
* Compact: +
Simple values will be about the same size as JSON.
Complex ones may be much smaller, since repeated values, especially strings, only need to be stored once.
* Efficient to convert into native objects: +
Numbers are binary, strings are raw UTF-8 without quoting, binary data is not base64-encoded.
Storing repeated values once means they only need to be converted into native objects once.
* Appendable: +
Fleece is what's known as a persistent data structure.
A Fleece document can be mutated by appending data to it.
The mutation is in effect a delta, so it's usually much smaller than the original document.
And the original document is unchanged, which is great for concurrency as well as (simple) version control.

For more information, see::
{url_fleece_on_github} |
{url_using_fleece} |
{url_fleece_hdr}

=== Values

FLValue is Fleece's ubiquitous data type.
It is a reference to a value of any type.

.FLValue
[source,{source-language}, subs="attributes+, nacros+"}]
----
FLString verified_account = FLValue_AsString(FLDict_Get(properties, FLSTR("verified_account"))); // <.>
----
<.> Here we retrieve a property value as a string.

== Slices

Another basic Fleece data type, `FLSlice` is a simple struct consisting of a pointer and a length.
It points to a range of memory, without  implying ownership
A lot of utility methods rely on it, including ones to convert to and from C++ and C strings.

An `FLSlice` literal can be written as FLSTR("something").

It has utility functions such as:

* `FLSlice_Equal` -- compares two slices for equality.
* `FLSlice_Compare` -- a 3-way comparison, like strcmp().

The `FLSliceResult` type is a subclass of FLSLice, which *does* own memory. +
It always points to a heap block that it manages.
You are responsible for calling FLSliceResult_Release when you're done with it.

For an example of `FLSliceResult` in use, see: <<ex-create-array>>.
It has functions which can be used to create new  `FLSliceResults` and to Release them when necessary.

* FLSliceResult_New
* FLSlice_Copy
* FLSliceResults_Release

NOTE: The null slice {NULL, 0} is represented by the constant `kFLSliceNull`. +
You test a slice for null by comparing its pointer (buf) with NULL.

Reference-counting is a manual exercise, see: xref:{param-module}:c_notes.adoc#lbl-ref-counted-objects[C Reference counted objects].
Whenever an `FLSliceResult` is returned from an API call, you are responsible for calling `FLSliceResult_Release` when you're done with it.

See: {url_flslice_hdr} for more details.

== Strings

Use the Fleece `FLSTR` function to provide string arguments to {cbl-t}

.Strings
[source,{source-language}, subs="attributes+, nacros+"}]
----
CBLDatabase* db = CBLDatabase_Open(FLSTR("my-database"), NULL, &err);
----

== Dictionaries

Use `FLMutableDict` to add K/V pairs to dictionaries and document as shown here.

[source,{source-language}, subs="attributes+, nacros+"}]
----
CBLDocument* newTask = CBLDocument_CreateWithID(FLSTR("xyz"));
FLMutableDict properties = CBLDocument_MutableProperties(newTask);
FLMutableDict_SetString(properties, FLSTR("type"), FLSTR("task"));
FLMutableDict_SetString(properties, FLSTR("owner"), FLSTR("todo"));
----
<.> don't forget to release resources once you have finished with them +
`FLMutableDict_Release(properties);`

[#lbl-fleece-arrays]
== Arrays

Use the FLValue function FLValue_AsArray to create an array from existing data.

[#ex-create-array]
.Create arrays
[source,{source-language}, subs="attributes+, nacros+"}]
----
// Create an array from the JSON string
FLError err;
FLSliceResult jsonData1 = FLData_ConvertJSON(json, &err); // <.>
FLArray hotels = FLValue_AsArray(FLValue_FromData(FLSliceResult_AsSlice(jsonData1), kFLTrusted));

FLSliceResult_Release(jsonData1);
----
<.> Here the FLSliceResult points to a Json string representing an array of hotels.

Use `FLArrayIterator` to iterate through arrays as shown in

[#ex-array-iteration]
.Array iteration
// Iterate through the array
[source,{source-language}, subs="attributes+, nacros+"}]
----
FLArrayIterator iter;
FLArrayIterator_Begin(hotels, &iter);
FLValue value;
while (NULL != (value = FLArrayIterator_GetValue(&iter))) {
    FLString hotel = FLValue_AsString(value);
    printf("Hotel :: %.*s\n", (int)hotel.size, (const char *)hotel.buf);
    FLArrayIterator_Next(&iter);
}
----

== Encoding a Fleece Object

. Construct an Encoder
. Tell the encoder to begin a collection: beginArray or beginDict
. Write values to the encoder, which adds them to the collection:
. If the collection is a dictionary, call writeKey to define the key for the value.
. To write a collection, recursively perform steps 2–4: Begin the collection, write . values, end it. +
To write a scalar, call: writeNull, writeBool, writeInt, etc.
. End the collection: endArray or endDict
. Call finish, which returns the encoded data


[#ex-encoding]
.Encoding  a Fleece object
====
// Iterate through the array
[source,{source-language}, subs="attributes+, nacros+"}]
----
Encoder enc;
enc.beginDict(); // <.>
enc.writeKey("dimensions"); // <.>
  enc.beginArray();
    enc.writeInt(10);
    enc.writeInt(16);
  enc.endArray();
enc.writeKey("color"); // <.>
enc.writeString("blue");
enc.endDict();
FLSliceResult encodedData = enc.finish(); // <.>
----
<.> Start the dictionary collection
<.> Here we create a property with the key _dimensions_ and a value comprising an array of two integer values representing, say, length and width
<.> Here we create a property with the key _color_ and a value "blue"
<.> Finish and return the slice as `encodedData`

====

== Encryptables

You can use the Fleece Extension API for setting and getting CBLEncryptable objects.

.Setter
[source, {source-language}, subs="attributes+, macros+"]
----

void FLSlot_SetEncryptableValue(FLSlot slot, CBLEncryptable *encryptable);
----

.Getter
[source, {source-language}, subs="attributes+, macros+"]
----
// Getter
CBLEncryptable* FLValue_GetEncryptableValue(FLValue v);
----

.IsEncryptable?
[source, {source-language}, subs="attributes+, macros+"]
----

// Check whether the value is an encrypted property or not
static bool FLValue_IsEncryptableValue(FLValue v);
----


.Encryption Constraints
[#tbl-encryption-constraints, cols="1h,4a", options="noheader"]
|===

| Document
| In the case of nested `encryptable` types, the replicator only encrypts the outer `encryptable`.

| Arrays
a| For compatibility with Server SDKS, encryptables are not supported within arrays.

The push replicator should detect and report an error if an encrypted property is found in an array.

| Blobs
| Encrypting blob’s content is not supported.

Where a Blob as a Fleece dictionary is specified in the encrypted property value, only the dictionary is encrypted; *not* the blob’s content.

|===

include::{root-partials}block-related-content-data.adoc[]
